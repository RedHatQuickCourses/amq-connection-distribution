<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Configuring ActiveMQArtemis Custom Resources for clustering :: ActiveMQ Artemis Clustering for High-Performance Messaging</title>
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">ActiveMQ Artemis Clustering for High-Performance Messaging</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/REPLACEREPONAME/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="amq-connection-distribution" data-version="1.0.0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">ActiveMQ Artemis Clustering for High-Performance Messaging</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../introduction-to-activemq-artemis/introduction-to-activemq-artemis.html">Introduction to ActiveMQ Artemis</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/understanding-message-oriented-middleware-mom.html">Understanding Message-Oriented Middleware (MOM)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/core-features-and-benefits-of-activemq-artemis.html">Core features and benefits of ActiveMQ Artemis</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/decoupling-producers-and-consumers.html">Decoupling Producers and Consumers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/asynchronous-communication-patterns.html">Asynchronous communication patterns</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/traffic-smoothing-and-competing-consumers.html">Traffic smoothing and competing consumers</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../client-side-challenges/client-side-challenges.html">Client-Side Challenges</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-challenges/bottlenecks-from-single-connection-to-a-single-broker.html">Bottlenecks from single connection to a single broker</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-challenges/impact-of-default-client-load-balancing-policies.html">Impact of default client load-balancing policies</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-challenges/reduced-cluster-throughput-due-to-message-redistribution.html">Reduced cluster throughput due to message redistribution</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-challenges/risk-of-high-volume-queues-paging-messages-to-disk.html">Risk of high-volume queues paging messages to disk</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../deploying-amq-on-openshift/deploying-amq-on-openshift.html">Deploying AMQ on OpenShift</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/overview-of-red-hat-amq-operator.html">Overview of Red Hat AMQ Operator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/installing-the-amq-operator-on-openshift.html">Installing the AMQ Operator on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/creating-an-activemqartemis-custom-resource-cr.html">Creating an ActiveMQArtemis Custom Resource (CR)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/configuring-a-two-node-activemq-artemis-cluster.html">Configuring a two-node ActiveMQ Artemis cluster</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/exposing-broker-services-for-client-connections.html">Exposing broker services for client connections</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../solutions-for-even-message-distribution/solutions-for-even-message-distribution.html">Solutions for Even Message Distribution</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions-for-even-message-distribution/strategies-for-client-side-load-balancing.html">Strategies for client-side load balancing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions-for-even-message-distribution/configuring-client-connection-factories-for-multiple-brokers.html">Configuring client connection factories for multiple brokers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions-for-even-message-distribution/techniques-to-distribute-messages-evenly-across-cluster-members.html">Techniques to distribute messages evenly across cluster members</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions-for-even-message-distribution/optimizing-client-connectivity-for-high-throughput.html">Optimizing client connectivity for high throughput</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster.html">Hands-on Lab: Deploying and Interacting with an ActiveMQ Artemis Cluster</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/setting-up-the-openshift-environment-for-amq-deployment.html">Setting up the OpenShift environment for AMQ deployment</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/deploying-a-two-node-activemq-artemis-cluster-using-the-operator.html">Deploying a two-node ActiveMQ Artemis cluster using the Operator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/developing-and-deploying-client-applications.html">Developing and deploying client applications</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/observing-message-distribution-and-cluster-behavior.html">Observing message distribution and cluster behavior</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/testing-failover-scenarios-and-ha-capabilities.html">Testing failover scenarios and HA capabilities</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">ActiveMQ Artemis Clustering for High-Performance Messaging</span>
    <span class="version">1.0.0</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">ActiveMQ Artemis Clustering for High-Performance Messaging</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1.0.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">ActiveMQ Artemis Clustering for High-Performance Messaging</a></li>
    <li><a href="configuring-activemqartemis-custom-resources-for-clustering.html">Configuring ActiveMQArtemis Custom Resources for clustering</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Configuring ActiveMQArtemis Custom Resources for clustering</h1>
<h1 id="_configuring_activemqartemis_custom_resources_for_clustering" class="sect0"><a class="anchor" href="#_configuring_activemqartemis_custom_resources_for_clustering"></a>Configuring ActiveMQArtemis Custom Resources for Clustering</h1>
<div class="paragraph">
<p>The deployment and management of ActiveMQ Artemis brokers on Kubernetes-based platforms like OpenShift are significantly streamlined through the use of Custom Resources (CRs) and Operators. The Red Hat AMQ Operator leverages the Kubernetes API to provide a native way to declare, configure, and manage ActiveMQ Artemis instances, including clustered deployments, directly through YAML manifests.</p>
</div>
<div class="sect1">
<h2 id="_introduction_to_activemqartemis_custom_resources"><a class="anchor" href="#_introduction_to_activemqartemis_custom_resources"></a>Introduction to ActiveMQArtemis Custom Resources</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ActiveMQ Artemis Custom Resources (CRs) act as a declarative blueprint for your broker deployments. Instead of manually configuring pods, services, routes, and persistent volumes, you define a single <code>ActiveMQArtemis</code> CR, and the Red Hat AMQ Operator translates this declaration into the necessary underlying Kubernetes resources. This approach simplifies operations, automates lifecycle management, and ensures consistency across environments.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="operator-overview.png" alt="Operator Overview" width="600" height="400">
</div>
</div>
<div class="paragraph">
<p>As introduced in the challenges section, clustered brokers can face issues like uneven connection distribution, bottlenecks from single connection points, and the overhead of message redistribution leading to reduced throughput and disk paging. By deploying ActiveMQ Artemis on OpenShift with the AMQ Operator and a properly configured CR, we can address these challenges by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Automated Scaling and High Availability</strong>: The Operator automatically provisions multiple broker instances and configures their clustering, ensuring high availability and fault tolerance.</p>
</li>
<li>
<p><strong>Server-Side Load Balancing</strong>: OpenShift&#8217;s service mechanisms and the broker&#8217;s internal features work together to distribute client connections and messages evenly across cluster members.</p>
</li>
<li>
<p><strong>Simplified Management</strong>: Declarative configuration through CRs reduces the complexity of managing distributed message brokers, making it easier to scale and maintain.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_anatomy_of_an_activemqartemis_custom_resource"><a class="anchor" href="#_anatomy_of_an_activemqartemis_custom_resource"></a>Anatomy of an ActiveMQArtemis Custom Resource</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>ActiveMQArtemis</code> Custom Resource defines the desired state of your ActiveMQ Artemis cluster. Let&#8217;s examine a typical configuration snippet used to deploy a clustered broker, as referenced in our context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: broker.amq.io/v1beta1
kind: ActiveMQArtemis
metadata:
  name: broker
  namespace: broker
spec:
  acceptors:
    - bindToAllInterfaces: true
      connectionsAllowed: -1
      expose: true
      name: broker
      port: 61617
      sslEnabled: true
      sslSecret: tls
  addressSettings:
    addressSetting:
      - match: '#'
        # ... other address settings ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s break down the key sections of this Custom Resource:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>apiVersion</code>: Specifies the version of the Kubernetes API the object is using. For the AMQ Broker Operator, this is typically <code>broker.amq.io/v1beta1</code>.</p>
</li>
<li>
<p><code>kind</code>: Indicates the type of Kubernetes resource, which is <code>ActiveMQArtemis</code> for deploying a broker instance.</p>
</li>
<li>
<p><code>metadata</code>: Contains essential identifying information for the object:</p>
</li>
<li>
<p><code>name</code>: A unique identifier for this particular ActiveMQArtemis deployment (e.g., <code>broker</code>).</p>
</li>
<li>
<p><code>namespace</code>: The OpenShift project or Kubernetes namespace where this broker will be deployed (e.g., <code>broker</code>).</p>
</li>
<li>
<p><code>spec</code>: This is the core of the CR, defining the desired state and detailed configuration of your ActiveMQ Artemis cluster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Within the <code>spec</code> section:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>acceptors</code>:</p>
</li>
<li>
<p>An <code>acceptor</code> defines a network endpoint where clients can connect to the broker. A single broker can host multiple acceptors, each configured for different protocols (e.g., AMQP, OpenWire, Core), SSL/non-SSL, or specific ports.</p>
</li>
<li>
<p><code>bindToAllInterfaces: true</code>: Configures the acceptor to listen on all available network interfaces within the broker pod.</p>
</li>
<li>
<p><code>connectionsAllowed: -1</code>: Specifies that there is no limit on the number of concurrent client connections this acceptor can handle.</p>
</li>
<li>
<p><code>expose: true</code>: This crucial setting instructs the Red Hat AMQ Operator to automatically create an OpenShift Route (for external access) or a Kubernetes Service (for internal cluster access) for this acceptor, making it accessible to clients.</p>
</li>
<li>
<p><code>name: broker</code>: A unique logical name for this specific acceptor configuration within the CR.</p>
</li>
<li>
<p><code>port: 61617</code>: The TCP port number on which this acceptor will listen for incoming client connections. This port typically corresponds to the Artemis Core protocol.</p>
</li>
<li>
<p><code>sslEnabled: true</code>: Enables SSL/TLS encryption for secure communication over this acceptor.</p>
</li>
<li>
<p><code>sslSecret: tls</code>: Specifies the name of the Kubernetes Secret that contains the SSL/TLS certificate and private key (<code>tls.crt</code> and <code>tls.key</code>). This secret must exist in the same namespace as the <code>ActiveMQArtemis</code> CR.</p>
</li>
<li>
<p><code>addressSettings</code>:</p>
</li>
<li>
<p>This section allows for fine-grained configuration of message addresses and queues within the broker.</p>
</li>
<li>
<p><code>addressSetting</code>: A list of specific address settings.</p>
</li>
<li>
<p><code>match: '#'</code>: A wildcard pattern indicating that the following settings apply to <strong>all</strong> addresses and queues on the broker. More specific patterns (e.g., <code>myQueue</code> or <code>topic.*</code>) can be used for targeted configurations.</p>
</li>
<li>
<p>Common additional settings (not fully shown in the context but crucial for clustering and performance):</p>
</li>
<li>
<p><code>maxSizeBytes</code>, <code>pageSizeBytes</code>: Control memory and disk usage for queues, preventing excessive memory consumption or disk paging for high-volume queues.</p>
</li>
<li>
<p><code>redistributionDelay</code>: As highlighted in the challenges, message redistribution between cluster nodes can introduce significant overhead. Setting this delay (e.g., to <code>0</code> for immediate redistribution) can impact overall cluster throughput.</p>
</li>
<li>
<p><code>deploymentPlan</code>: (While not explicitly shown in the provided context snippet, this is a fundamental part of deploying a clustered broker with the Operator).</p>
</li>
<li>
<p><code>size</code>: This field (e.g., <code>size: 2</code>) is typically found under <code>spec.deploymentPlan</code> and specifies the desired number of broker instances the Operator should deploy to form a cluster. For example, to achieve a two-node cluster for high availability and load balancing, you would set <code>size: 2</code>. The Operator then manages the creation of the underlying StatefulSet, individual broker pods, and their internal clustering configuration.</p>
</li>
<li>
<p><code>image</code>: Specifies the container image to use for the ActiveMQ Artemis broker pods (e.g., <code>registry.redhat.io/amq7/amq-broker-rhel8:7.10</code>).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hands_on_activity_deploying_a_clustered_activemq_artemis_broker_on_openshift"><a class="anchor" href="#_hands_on_activity_deploying_a_clustered_activemq_artemis_broker_on_openshift"></a>Hands-on Activity: Deploying a Clustered ActiveMQ Artemis Broker on OpenShift</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This activity guides you through deploying a two-node ActiveMQ Artemis cluster on OpenShift using the Red Hat AMQ Operator and an <code>ActiveMQArtemis</code> Custom Resource.</p>
</div>
<div class="sect2">
<h3 id="_prerequisites"><a class="anchor" href="#_prerequisites"></a>Prerequisites</h3>
<div class="ulist">
<ul>
<li>
<p>An OpenShift cluster with <code>oc</code> CLI configured and logged in.</p>
</li>
<li>
<p>The Red Hat AMQ Operator installed in your cluster. (If not installed, please follow the official Red Hat documentation to subscribe to and install the Operator in your desired namespace, e.g., <code>amq-broker</code>). For this lab, we&#8217;ll assume the operator is installed and configured to watch resources in the <code>broker</code> namespace.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_step_1_create_a_project_namespace"><a class="anchor" href="#_step_1_create_a_project_namespace"></a>Step 1: Create a Project (Namespace)</h3>
<div class="paragraph">
<p>First, create a dedicated OpenShift project (namespace) for your broker deployment.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">oc new-project broker</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_step_2_create_a_tls_secret_for_ssl_communication"><a class="anchor" href="#_step_2_create_a_tls_secret_for_ssl_communication"></a>Step 2: Create a TLS Secret for SSL Communication</h3>
<div class="paragraph">
<p>Since our <code>ActiveMQArtemis</code> CR will specify <code>sslEnabled: true</code> and <code>sslSecret: tls</code> for secure communication, we need to create a Kubernetes Secret named <code>tls</code> containing the necessary certificate and private key. For demonstration purposes, we&#8217;ll generate a self-signed certificate.</p>
</div>
<div class="listingblock">
<div class="title">Generate a self-signed certificate and key:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/CN=activemq-artemis-broker"</code></pre>
</div>
</div>
<div class="paragraph">
<p>This command creates two files: <code>tls.key</code> (the private key) and <code>tls.crt</code> (the certificate). The <code>CN</code> (Common Name) in a production environment should match the service name or route hostname that clients will use to connect. For this lab, <code>activemq-artemis-broker</code> is sufficient.</p>
</div>
<div class="listingblock">
<div class="title">Create the Kubernetes Secret named <code>tls</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">oc create secret tls tls --cert=tls.crt --key=tls.key -n broker</code></pre>
</div>
</div>
<div class="paragraph">
<p>Verify that the secret has been successfully created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">oc get secret tls -n broker</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_step_3_define_the_activemqartemis_custom_resource"><a class="anchor" href="#_step_3_define_the_activemqartemis_custom_resource"></a>Step 3: Define the ActiveMQArtemis Custom Resource</h3>
<div class="paragraph">
<p>Create a file named <code>artemis-cluster-cr.yaml</code> with the following content. This configuration builds upon the context provided and extends it to deploy a fully functional two-node cluster with multiple common protocols.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: broker.amq.io/v1beta1
kind: ActiveMQArtemis
metadata:
  name: my-broker-cluster
  namespace: broker
spec:
  deploymentPlan:
    size: 2 # This specifies a two-node cluster for high availability and load balancing
    image: registry.redhat.io/amq7/amq-broker-rhel8:7.10 # Specify a suitable AMQ Broker image
  acceptors:
    - name: amqp
      port: 5672
      protocol: amqp
      expose: true
      sslEnabled: true
      sslSecret: tls
      bindToAllInterfaces: true
      connectionsAllowed: -1
    - name: openwire
      port: 61616
      protocol: openwire
      expose: true
      sslEnabled: true
      sslSecret: tls
      bindToAllInterfaces: true
      connectionsAllowed: -1
    - name: core
      port: 61617
      protocol: core
      expose: true
      sslEnabled: true
      sslSecret: tls
      bindToAllInterfaces: true
      connectionsAllowed: -1
  addressSettings:
    addressSetting:
      - match: '#' # Apply these settings to all addresses
        maxSizeBytes: -1 # No size limit for messages in memory
        maxDeliveryAttempts: 10
        redistributionDelay: 0 # Set to 0 for immediate redistribution to minimize overhead
        deadLetterAddress: DLQ
        expiryAddress: ExpiryQueue
  # Optional: Persistence configuration is highly recommended for production environments
  # journalStorage:
  #   size: 1Gi
  #   storageClassName: standard # Use your cluster's default storage class or a specific one
  # bindingsStorage:
  #   size: 1Gi
  #   storageClassName: standard
  # largeMessagesStorage:
  #   size: 1Gi
  #   storageClassName: standard</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Explanation of Key Configuration Points:</div>
<ul>
<li>
<p><code>metadata.name: my-broker-cluster</code>: A more descriptive name for our cluster deployment.</p>
</li>
<li>
<p><code>deploymentPlan.size: 2</code>: This critical setting instructs the Red Hat AMQ Operator to deploy <strong>two</strong> ActiveMQ Artemis broker instances, which will automatically form a cluster.</p>
</li>
<li>
<p><code>deploymentPlan.image</code>: Specifies the container image for the brokers. Using a Red Hat certified image is recommended.</p>
</li>
<li>
<p><code>acceptors</code>: We&#8217;ve included <code>amqp</code> (port <code>5672</code>), <code>openwire</code> (port <code>61616</code>), and <code>core</code> (port <code>61617</code>) acceptors, all exposed via OpenShift Routes and secured with SSL, as is common in real-world deployments. The <code>core</code> acceptor here matches the port from the context.</p>
</li>
<li>
<p><code>addressSettings.addressSetting.redistributionDelay: 0</code>: As mentioned in the challenges, message redistribution overhead can reduce cluster throughput. Setting this to <code>0</code> ensures immediate redistribution, which can be beneficial for high-volume queues.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_step_4_apply_the_custom_resource"><a class="anchor" href="#_step_4_apply_the_custom_resource"></a>Step 4: Apply the Custom Resource</h3>
<div class="paragraph">
<p>Apply the <code>artemis-cluster-cr.yaml</code> file to your OpenShift cluster using the <code>oc apply</code> command.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">oc apply -f artemis-cluster-cr.yaml -n broker</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Red Hat AMQ Operator will now reconcile this Custom Resource, creating and configuring all the necessary Kubernetes resources, which include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>StatefulSet</code> that manages the two ActiveMQ Artemis pods.</p>
</li>
<li>
<p>Headless Services for internal cluster communication between brokers.</p>
</li>
<li>
<p>Standard Services and OpenShift Routes for client access to each of the defined acceptors.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_step_5_verify_the_deployment"><a class="anchor" href="#_step_5_verify_the_deployment"></a>Step 5: Verify the Deployment</h3>
<div class="paragraph">
<p>Monitor the deployment process and verify that your cluster is fully up and running.</p>
</div>
<div class="listingblock">
<div class="title">Check the pods:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">oc get pods -n broker</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should see two pods named <code>my-broker-cluster-ss-0</code> and <code>my-broker-cluster-ss-1</code> (or similar naming based on the operator&#8217;s convention) in a <code>Running</code> state.</p>
</div>
<div class="listingblock">
<div class="title">Check the services and routes:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">oc get svc -n broker
oc get route -n broker</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should observe services and routes corresponding to your <code>amqp</code>, <code>openwire</code>, and <code>core</code> acceptors (e.g., <code>my-broker-cluster-amqp</code>, <code>my-broker-cluster-openwire</code>, <code>my-broker-cluster-core</code>). Make a note of the hostnames of these routes; these are the external endpoints your client applications will use to connect.</p>
</div>
<div class="listingblock">
<div class="title">Check the <code>ActiveMQArtemis</code> CR status:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">oc get activemqartemis my-broker-cluster -n broker -o yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>Examine the <code>status</code> section within the output. It should indicate that the cluster is <code>Running</code> and healthy, providing details about the deployed brokers.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_client_connection_to_a_clustered_artemis_environment"><a class="anchor" href="#_client_connection_to_a_clustered_artemis_environment"></a>Client Connection to a Clustered Artemis Environment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Once your ActiveMQ Artemis cluster is deployed and accessible via OpenShift Routes, client applications need to connect in a way that fully leverages the cluster&#8217;s high availability and message load-balancing capabilities.</p>
</div>
<div class="paragraph">
<p>The provided context gives an example of a connection URL and the use of <code>JmsPoolConnectionFactory</code>. For client applications, especially those connecting from outside the OpenShift cluster, you would typically use the hostname of the exposed OpenShift Route for your chosen protocol (e.g., <code>openwire</code> or <code>amqp</code>).</p>
</div>
<div class="paragraph">
<p>A connection URL similar to the one shown in the context is crucial for robust client-side behavior:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.artemis.url=ssl://&lt;ROUTE_HOSTNAME&gt;:61616?ha=true&amp;reconnectAttempts=30&amp;retryInterval=5000&amp;connectionLoadBalancingPolicyClassName=org.apache.activemq.artemis.api.core.client.loadbalance.RandomConnectionLoadBalancingPolicy&amp;callTimeout=2000
quarkus.artemis.username=admin
quarkus.artemis.password=admin</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Explanation of URL Parameters for Clustered Client Connections:</div>
<ul>
<li>
<p><code>ssl://&lt;ROUTE_HOSTNAME&gt;:61616</code>: Specifies the SSL protocol and the hostname/port of the OpenShift Route for the OpenWire acceptor. Replace <code>&lt;ROUTE_HOSTNAME&gt;</code> with the actual route host you obtained from <code>oc get route</code>.</p>
</li>
<li>
<p><code>ha=true</code>: Enables ActiveMQ Artemis&#8217;s client-side High Availability features. This allows the client to automatically detect if its primary connection to a broker is lost and attempt to failover to another available broker in the cluster, ensuring continuous operation.</p>
</li>
<li>
<p><code>reconnectAttempts</code>, <code>retryInterval</code>, <code>reconnectInitialDelay</code>: These parameters configure the client&#8217;s reconnection behavior, determining how many times and how often it attempts to reconnect after a connection failure.</p>
</li>
<li>
<p><code>connectionLoadBalancingPolicyClassName=org.apache.activemq.artemis.api.core.client.loadbalance.RandomConnectionLoadBalancingPolicy</code>: This is a critical setting for client-side load balancing. It instructs the ActiveMQ Artemis client to randomly select an available broker from the list of cluster members when establishing new connections. This policy is instrumental in distributing client connections evenly across the cluster, directly addressing the challenge of "uneven connection distribution across cluster nodes" and preventing a single broker from becoming a bottleneck.</p>
</li>
<li>
<p><code>callTimeout</code>: Sets a timeout for synchronous operations or calls made over the connection.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Furthermore, wrapping the <code>ActiveMQConnectionFactory</code> in a <code>JmsPoolConnectionFactory</code> (from the <code>pooled-jms</code> library by messaginghub) is a highly recommended practice, especially within application frameworks like Spring or Quarkus, as evidenced by the context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.smallrye.common.annotation.Identifier;
import jakarta.enterprise.inject.Produces;
import jakarta.inject.Singleton;
import org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.messaginghub.pooled.jms.JmsPoolConnectionFactory;

@Singleton
public class MyConfig {

    @ConfigProperty(name = "quarkus.artemis.url")
    String url;

    @Produces
    @Identifier("pcfProducer") // Identifies this as the producer connection factory
    public JmsPoolConnectionFactory producerConnectionFactory(@ConfigProperty(name = "quarkus.artemis.username") String username,
                                                              @ConfigProperty(name = "quarkus.artemis.password") String password) {
        ActiveMQConnectionFactory artemisConnectionFactory = new ActiveMQConnectionFactory(url);
        artemisConnectionFactory.setUser(username);
        artemisConnectionFactory.setPassword(password);

        JmsPoolConnectionFactory pcf = new JmsPoolConnectionFactory();
        pcf.setConnectionFactory(artemisConnectionFactory);
        pcf.setMaxConnections(10); // Set to be &gt;= number of brokers for effective load balancing
        // pcf.setMaxSessionsPerConnection(1); // Tune based on application requirements
        // pcf.setConnectionCheckInterval(30000); // How often to check for idle connections
        // pcf.setConnectionIdleTimeout(30000); // Timeout for idle connections
        return pcf;
    }
    // A similar method can be provided for a consumer-specific connection factory,
    // allowing for independent tuning of connection pool settings based on usage patterns.
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Key Aspects of <code>JmsPoolConnectionFactory</code> for Clustered Environments:</div>
<ul>
<li>
<p><strong>Connection Pooling</strong>: <code>JmsPoolConnectionFactory</code> reuses JMS connections, significantly reducing the overhead associated with establishing new connections for every message producer or consumer.</p>
</li>
<li>
<p><strong>Separation of Producer/Consumer Factories</strong>: The context implies the ability to separate producer and consumer connection factories. This allows for independent tuning of connection pool parameters for each type of client, preventing contention and ensuring optimal resource allocation (e.g., producers might need more connections, consumers fewer but more session-per-connection).</p>
</li>
<li>
<p><strong><code>setMaxConnections</code></strong>: This property (e.g., <code>pcf.setMaxConnections(10)</code>) is crucial for client-side load balancing in a clustered environment. By setting <code>setMaxConnections</code> to a value greater than or equal to the number of brokers in your cluster (e.g., <code>2</code> for a 2-node cluster, or higher if more parallel connections are needed), the pooled factory can establish multiple underlying physical connections, each potentially to a different broker instance within the cluster. This effectively distributes the load of client connections across the entire cluster, directly addressing the challenge of "bottlenecks from single connection points."</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By combining the declarative power of OpenShift Operators for broker deployment, properly configured <code>ActiveMQArtemis</code> Custom Resources for cluster setup, and intelligent client-side connection management with <code>JmsPoolConnectionFactory</code> and load-balancing policies, you can achieve a robust, highly available, and performant ActiveMQ Artemis messaging cluster.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
