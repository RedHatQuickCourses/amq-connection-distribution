<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Reactive messaging with Quarkus and Artemis :: ActiveMQ Artemis Clustering for High-Performance Messaging</title>
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">ActiveMQ Artemis Clustering for High-Performance Messaging</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/REPLACEREPONAME/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="amq-connection-distribution" data-version="1.0.0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">ActiveMQ Artemis Clustering for High-Performance Messaging</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../introduction-to-activemq-artemis/introduction-to-activemq-artemis.html">Introduction to ActiveMQ Artemis</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/understanding-message-oriented-middleware-mom.html">Understanding Message-Oriented Middleware (MOM)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/core-features-and-benefits-of-activemq-artemis.html">Core features and benefits of ActiveMQ Artemis</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/decoupling-producers-and-consumers.html">Decoupling Producers and Consumers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/asynchronous-communication-patterns.html">Asynchronous communication patterns</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/traffic-smoothing-and-competing-consumers.html">Traffic smoothing and competing consumers</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../client-side-challenges/client-side-challenges.html">Client-Side Challenges</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-challenges/bottlenecks-from-single-connection-to-a-single-broker.html">Bottlenecks from single connection to a single broker</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-challenges/impact-of-default-client-load-balancing-policies.html">Impact of default client load-balancing policies</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-challenges/reduced-cluster-throughput-due-to-message-redistribution.html">Reduced cluster throughput due to message redistribution</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-challenges/risk-of-high-volume-queues-paging-messages-to-disk.html">Risk of high-volume queues paging messages to disk</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../deploying-amq-on-openshift/deploying-amq-on-openshift.html">Deploying AMQ on OpenShift</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/overview-of-red-hat-amq-operator.html">Overview of Red Hat AMQ Operator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/installing-the-amq-operator-on-openshift.html">Installing the AMQ Operator on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/creating-an-activemqartemis-custom-resource-cr.html">Creating an ActiveMQArtemis Custom Resource (CR)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/configuring-a-two-node-activemq-artemis-cluster.html">Configuring a two-node ActiveMQ Artemis cluster</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/exposing-broker-services-for-client-connections.html">Exposing broker services for client connections</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../solutions-for-even-message-distribution/solutions-for-even-message-distribution.html">Solutions for Even Message Distribution</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions-for-even-message-distribution/strategies-for-client-side-load-balancing.html">Strategies for client-side load balancing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions-for-even-message-distribution/configuring-client-connection-factories-for-multiple-brokers.html">Configuring client connection factories for multiple brokers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions-for-even-message-distribution/techniques-to-distribute-messages-evenly-across-cluster-members.html">Techniques to distribute messages evenly across cluster members</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions-for-even-message-distribution/optimizing-client-connectivity-for-high-throughput.html">Optimizing client connectivity for high throughput</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster.html">Hands-on Lab: Deploying and Interacting with an ActiveMQ Artemis Cluster</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/setting-up-the-openshift-environment-for-amq-deployment.html">Setting up the OpenShift environment for AMQ deployment</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/deploying-a-two-node-activemq-artemis-cluster-using-the-operator.html">Deploying a two-node ActiveMQ Artemis cluster using the Operator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/developing-and-deploying-client-applications.html">Developing and deploying client applications</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/observing-message-distribution-and-cluster-behavior.html">Observing message distribution and cluster behavior</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/testing-failover-scenarios-and-ha-capabilities.html">Testing failover scenarios and HA capabilities</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">ActiveMQ Artemis Clustering for High-Performance Messaging</span>
    <span class="version">1.0.0</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">ActiveMQ Artemis Clustering for High-Performance Messaging</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1.0.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">ActiveMQ Artemis Clustering for High-Performance Messaging</a></li>
    <li><a href="reactive-messaging-with-quarkus-and-artemis.html">Reactive messaging with Quarkus and Artemis</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Reactive messaging with Quarkus and Artemis</h1>
<h1 id="_reactive_messaging_with_quarkus_and_artemis" class="sect0"><a class="anchor" href="#_reactive_messaging_with_quarkus_and_artemis"></a>Reactive Messaging with Quarkus and Artemis</h1>
<div class="paragraph">
<p>This section delves into how Quarkus leverages its reactive capabilities, specifically with the SmallRye Reactive Messaging extension, to build efficient and scalable messaging applications integrated with ActiveMQ Artemis.</p>
</div>
<div class="sect1">
<h2 id="_introduction_to_reactive_messaging_in_quarkus"><a class="anchor" href="#_introduction_to_reactive_messaging_in_quarkus"></a>Introduction to Reactive Messaging in Quarkus</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reactive programming is an asynchronous programming paradigm concerned with data streams and the propagation of change. It&#8217;s particularly well-suited for modern microservices architectures where applications need to be highly responsive, resilient, elastic, and message-driven. Quarkus embraces this paradigm, providing a reactive foundation that allows developers to build non-blocking, event-driven applications efficiently.</p>
</div>
<div class="paragraph">
<p>Quarkus&#8217;s reactive messaging capabilities are powered by the <code>SmallRye Reactive Messaging</code> project, which implements the Eclipse MicroProfile Reactive Messaging specification. This specification provides a common set of APIs and concepts for building reactive, message-driven microservices.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_reactive_messaging"><a class="anchor" href="#_why_reactive_messaging"></a>Why Reactive Messaging?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Traditional synchronous blocking I/O models can lead to inefficient resource utilization, especially when dealing with external services or message brokers that might introduce latency. Reactive messaging addresses these challenges by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Improved Responsiveness:</strong> Applications can respond to events immediately without waiting for long-running operations to complete.</p>
</li>
<li>
<p><strong>Better Resource Utilization:</strong> Non-blocking I/O allows a small number of threads to handle a large number of concurrent operations, leading to more efficient use of CPU and memory.</p>
</li>
<li>
<p><strong>Enhanced Resilience:</strong> Reactive systems are designed to handle failures gracefully, allowing for easier implementation of retry mechanisms, backpressure, and circuit breakers.</p>
</li>
<li>
<p><strong>Scalability:</strong> The asynchronous nature makes it easier to scale horizontally and handle increased message throughput.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_quarkus_smallrye_reactive_messaging_overview"><a class="anchor" href="#_quarkus_smallrye_reactive_messaging_overview"></a>Quarkus SmallRye Reactive Messaging Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>SmallRye Reactive Messaging provides a powerful and flexible way to connect to various messaging systems, including Kafka, AMQP (which ActiveMQ Artemis supports), MQTT, and more. It abstracts away the low-level details of message broker interactions, allowing developers to focus on the business logic.</p>
</div>
<div class="paragraph">
<p>Key concepts include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Channels:</strong> Logical names for data streams that messages flow through.</p>
</li>
<li>
<p><strong><code>@Incoming</code>:</strong> Annotates methods that consume messages from a specific channel.</p>
</li>
<li>
<p><strong><code>@Outgoing</code>:</strong> Annotates methods that produce messages to a specific channel.</p>
</li>
<li>
<p><strong><code>Message&lt;T&gt;</code>:</strong> A wrapper around the payload <code>T</code> that also provides access to metadata and acknowledgment mechanisms.</p>
</li>
<li>
<p><strong><code>Emitter&lt;T&gt;</code>:</strong> An injectable component used to programmatically send messages to an <code>@Outgoing</code> channel.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_integrating_reactive_messaging_with_activemq_artemis"><a class="anchor" href="#_integrating_reactive_messaging_with_activemq_artemis"></a>Integrating Reactive Messaging with ActiveMQ Artemis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus can easily integrate with ActiveMQ Artemis using the <code>quarkus-smallrye-reactive-messaging-amqp</code> extension. This extension provides the necessary connectors to send and receive messages over AMQP 1.0, which is the preferred protocol for modern messaging.</p>
</div>
<div class="paragraph">
<p>To use ActiveMQ Artemis with Quarkus Reactive Messaging, you&#8217;ll need to add the following dependency to your <code>pom.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-reactive-messaging-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this dependency, Quarkus automatically configures an AMQP client connection based on your <code>application.properties</code>.</p>
</div>
<div class="sect2">
<h3 id="_configuring_quarkus_for_activemq_artemis_connectivity"><a class="anchor" href="#_configuring_quarkus_for_activemq_artemis_connectivity"></a>Configuring Quarkus for ActiveMQ Artemis Connectivity</h3>
<div class="paragraph">
<p>Configuration for the AMQP connector is typically done in <code>src/main/resources/application.properties</code>. You define named AMQP brokers, and then link your channels to these brokers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># AMQP Broker Configuration
# Define a named AMQP broker connection
amqp-brokers.my-artemis.host=localhost
amqp-brokers.my-artemis.port=5672
amqp-brokers.my-artemis.username=artemis
amqp-brokers.my-artemis.password=artemis
amqp-brokers.my-artemis.tracing-enabled=true # Enable OpenTracing integration if desired

# Outgoing channel configuration
mp.messaging.outgoing.my-outgoing-channel.connector=smallrye-amqp
mp.messaging.outgoing.my-outgoing-channel.broker-name=my-artemis # Link to the named broker
mp.messaging.outgoing.my-outgoing-channel.address=my-queue # Target queue/topic on Artemis
mp.messaging.outgoing.my-outgoing-channel.durable=true
mp.messaging.outgoing.my-outgoing-channel.persistent=true

# Incoming channel configuration
mp.messaging.incoming.my-incoming-channel.connector=smallrye-amqp
mp.messaging.incoming.my-incoming-channel.broker-name=my-artemis # Link to the named broker
mp.messaging.incoming.my-incoming-channel.address=my-queue # Source queue/topic on Artemis
mp.messaging.incoming.my-incoming-channel.durable=true
mp.messaging.incoming.my-incoming-channel.auto-acknowledgement=false # We'll acknowledge manually</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>amqp-brokers.my-artemis.*</code>: Defines a named AMQP broker connection <code>my-artemis</code>.</p>
</li>
<li>
<p><code>mp.messaging.outgoing.my-outgoing-channel.*</code>: Configures an outgoing channel named <code>my-outgoing-channel</code>. It uses the <code>smallrye-amqp</code> connector and targets the <code>my-queue</code> address on the <code>my-artemis</code> broker.</p>
</li>
<li>
<p><code>mp.messaging.incoming.my-incoming-channel.*</code>: Configures an incoming channel named <code>my-incoming-channel</code>, also connected to <code>my-queue</code> on <code>my-artemis</code>. <code>auto-acknowledgement=false</code> is set for manual acknowledgment.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_hands_on_activity_implementing_a_reactive_producer"><a class="anchor" href="#_hands_on_activity_implementing_a_reactive_producer"></a>Hands-on Activity: Implementing a Reactive Producer</h3>
<div class="paragraph">
<p>Let&#8217;s create a Quarkus service that periodically sends messages to an ActiveMQ Artemis queue using reactive messaging.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites:</div>
<ul>
<li>
<p>A running ActiveMQ Artemis instance (e.g., deployed on OpenShift or locally).</p>
</li>
<li>
<p>A Quarkus project set up with the <code>quarkus-smallrye-reactive-messaging-amqp</code> dependency.</p>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Steps:</div>
<ol class="arabic">
<li>
<p><strong>Create a simple Message POJO</strong> (optional, but good practice):
[source,java]
----
// src/main/java/org/acme/quarkus/artemis/MessageData.java
package org.acme.quarkus.artemis;</p>
<div class="literalblock">
<div class="content">
<pre>public class MessageData {
    public String content;
    public long timestamp;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>public MessageData() {
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>public MessageData(String content, long timestamp) {
    this.content = content;
    this.timestamp = timestamp;
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    @Override
    public String toString() {
        return "MessageData{" +
               "content='" + content + '\'' +
               ", timestamp=" + timestamp +
               '}';
    }
}
----</pre>
</div>
</div>
</li>
<li>
<p><strong>Implement the Reactive Producer Service:</strong>
[source,java]
----
// src/main/java/org/acme/quarkus/artemis/ReactiveProducerService.java
package org.acme.quarkus.artemis;</p>
<div class="literalblock">
<div class="content">
<pre>import io.quarkus.runtime.StartupEvent;
import io.smallrye.mutiny.Multi;
import io.smallrye.reactive.messaging.annotations.Emitter;
import io.smallrye.reactive.messaging.annotations.Channel;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>import java.time.Duration;
import java.util.Random;
import java.util.concurrent.atomic.AtomicInteger;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@ApplicationScoped
public class ReactiveProducerService {</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>private static final Random RANDOM = new Random();
private AtomicInteger counter = new AtomicInteger();</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>// Inject an Emitter for the 'my-outgoing-channel'
@Channel("my-outgoing-channel")
Emitter&lt;MessageData&gt; messageEmitter; // Emitter for our POJO</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>// Or if you prefer to emit raw strings/JSON:
// @Channel("my-outgoing-channel")
// Emitter&lt;String&gt; stringEmitter;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>void onStart(@Observes StartupEvent ev) {
    // Schedule sending messages every 5 seconds
    Multi.interval(Duration.ofSeconds(5))
        .onItem().transform(tick -&gt; {
            int id = counter.incrementAndGet();
            String content = "Hello from Quarkus reactive producer #" + id;
            long timestamp = System.currentTimeMillis();
            MessageData data = new MessageData(content, timestamp);
            System.out.println("Producing message: " + data);
            return data;
        })
        .subscribe().with(messageData -&gt; {
            // Send the MessageData object. Quarkus will serialize it to JSON/AMQP message.
            messageEmitter.send(messageData);
        });
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    // Alternative method using @Outgoing annotation for producing
    // @Outgoing("my-outgoing-channel")
    // public Multi&lt;MessageData&gt; generateMessages() {
    //     return Multi.interval(Duration.ofSeconds(5))
    //         .onItem().transform(tick -&gt; {
    //             int id = counter.incrementAndGet();
    //             String content = "Hello from Quarkus reactive producer (via @Outgoing) #" + id;
    //             long timestamp = System.currentTimeMillis();
    //             MessageData data = new MessageData(content, timestamp);
    //             System.out.println("Producing message via @Outgoing: " + data);
    //             return data;
    //         });
    // }
}
----
In this example, `ReactiveProducerService` uses `@Channel("my-outgoing-channel") Emitter&lt;MessageData&gt; messageEmitter;` to inject an `Emitter`. Upon application startup, it schedules an interval using `Multi.interval` and sends `MessageData` objects to the `my-outgoing-channel`. Quarkus will automatically serialize `MessageData` to a format suitable for AMQP (typically JSON by default).</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_hands_on_activity_implementing_a_reactive_consumer"><a class="anchor" href="#_hands_on_activity_implementing_a_reactive_consumer"></a>Hands-on Activity: Implementing a Reactive Consumer</h3>
<div class="paragraph">
<p>Now, let&#8217;s create a service that consumes messages from the same ActiveMQ Artemis queue reactively.</p>
</div>
<div class="olist arabic">
<div class="title">Steps:</div>
<ol class="arabic">
<li>
<p><strong>Implement the Reactive Consumer Service:</strong>
[source,java]
----
// src/main/java/org/acme/quarkus/artemis/ReactiveConsumerService.java
package org.acme.quarkus.artemis;</p>
<div class="literalblock">
<div class="content">
<pre>import io.smallrye.reactive.messaging.annotations.Channel;
import io.smallrye.reactive.messaging.annotations.Incoming;
import io.smallrye.reactive.messaging.annotations.Acknowledgment;
import jakarta.enterprise.context.ApplicationScoped;
import org.eclipse.microprofile.reactive.messaging.Message;
import io.smallrye.mutiny.Uni;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@ApplicationScoped
public class ReactiveConsumerService {</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>// Method to consume messages from 'my-incoming-channel'
// Acknowledgment.Completion is used for manual acknowledgment after processing.
@Incoming("my-incoming-channel")
@Acknowledgment(Acknowledgment.Strategy.POST_PROCESSING)
public Uni&lt;Void&gt; consume(Message&lt;MessageData&gt; message) { // Consume Message&lt;MessageData&gt;
    MessageData data = message.getPayload();
    System.out.println("Reactive Consumer received message: " + data.content + " at " + data.timestamp);</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    // Simulate some asynchronous processing
    return Uni.createFrom().item(data)
        .onItem().delayIt().by(java.time.Duration.ofMillis(RANDOM.nextInt(100) + 50)) // Random delay
        .onItem().invoke(processedData -&gt; {
            System.out.println("Processed message successfully: " + processedData.content);
        })
        .onFailure().invoke(failure -&gt; {
            System.err.println("Failed to process message: " + data.content + " - " + failure.getMessage());
            // NACK the message if processing fails, depends on broker capabilities and connector configuration
            // return message.nack(failure); // nack() is available on Message interface for certain connectors
        })
        .onItem().ignoreAsUni() // Return Uni&lt;Void&gt; to signal completion
        .chain(() -&gt; message.ack()); // Acknowledge the message only after successful processing
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    // You can also consume raw payloads directly if you don't need Message metadata
    // @Incoming("my-incoming-channel")
    // @Acknowledgment(Acknowledgment.Strategy.POST_PROCESSING)
    // public Uni&lt;Void&gt; consumePayload(MessageData data) {
    //     System.out.println("Reactive Consumer received direct payload: " + data.content);
    //     return Uni.createFrom().item(data)
    //             .onItem().delayIt().by(java.time.Duration.ofMillis(50))
    //             .onItem().ignoreAsUni();
    // }
}
----</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>In `ReactiveConsumerService`:</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>@Incoming("my-incoming-channel")</code> annotation indicates that this method consumes messages from the <code>my-incoming-channel</code>.</p>
</li>
<li>
<p><code>@Acknowledgment(Acknowledgment.Strategy.POST_PROCESSING)</code> specifies that the message should be acknowledged <strong>after</strong> the <code>consume</code> method has successfully processed it and the returned <code>Uni&lt;Void&gt;</code> completes.</p>
</li>
<li>
<p>The method signature <code>public Uni&lt;Void&gt; consume(Message&lt;MessageData&gt; message)</code> allows us to receive the full <code>Message</code> object, giving access to its payload (<code>message.getPayload()</code>) and providing fine-grained control over acknowledgment (<code>message.ack()</code> or <code>message.nack()</code>).</p>
</li>
<li>
<p>The <code>Uni</code> return type allows for asynchronous processing of the message payload. We simulate some processing with a delay and then explicitly acknowledge the message with <code>message.ack()</code>.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_running_the_example"><a class="anchor" href="#_running_the_example"></a>Running the Example</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Ensure ActiveMQ Artemis is running and accessible at <code>localhost:5672</code> (or adjust <code>application.properties</code>).</p>
</li>
<li>
<p>Compile and run the Quarkus application:
[source,bash]
----
mvn clean compile quarkus:dev
----</p>
</li>
<li>
<p>Observe the console output:</p>
<div class="ulist">
<ul>
<li>
<p>The <code>ReactiveProducerService</code> will log messages it&#8217;s sending.</p>
</li>
<li>
<p>The <code>ReactiveConsumerService</code> will log messages it receives and processes.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>You should see messages flowing from the producer, through ActiveMQ Artemis, and then consumed by the reactive consumer.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_considerations"><a class="anchor" href="#_advanced_considerations"></a>Advanced Considerations</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><strong>Backpressure:</strong> SmallRye Reactive Messaging automatically applies backpressure mechanisms to prevent consumers from being overwhelmed by producers. This is handled internally by the reactive streams specification.</p>
</li>
<li>
<p><strong>Error Handling:</strong> You can define error handling strategies, such as retries or dead-letter queues, either via connector configurations or by handling exceptions within your <code>@Incoming</code> methods. For <code>Uni&lt;Void&gt;</code> methods, an unhandled exception would typically lead to a NACK (negative acknowledgment) to the broker, potentially triggering redelivery.</p>
</li>
<li>
<p><strong>Message Transformations:</strong> Use intermediate <code>@Outgoing</code> and <code>@Incoming</code> methods to transform messages between channels before they reach the final consumer or leave the application.</p>
</li>
<li>
<p><strong>Concurrency:</strong> Quarkus handles concurrency for <code>@Incoming</code> methods. By default, messages are processed sequentially by a single consumer instance per channel, but you can configure worker pools or use <code>io.smallrye.reactive.messaging.annotations.Blocking</code> to delegate processing to a separate thread pool for blocking operations.</p>
</li>
<li>
<p><strong>Tracing and Metrics:</strong> Quarkus and SmallRye Reactive Messaging integrate well with OpenTelemetry for distributed tracing and Micrometer for metrics, providing deep observability into your messaging flows.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Reactive messaging with Quarkus and ActiveMQ Artemis provides a robust and efficient foundation for building high-performance, resilient, and scalable message-driven microservices. By leveraging the AMQP connector and the power of SmallRye Reactive Messaging, developers can easily integrate with Artemis while benefiting from Quarkus&#8217;s development velocity and runtime efficiency.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
