<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Handling message durability and reliability :: Building Resilient Messaging Applications with ActiveMQ Artemis and OpenShift</title>
    <link rel="prev" href="ensuring-message-ordering-in-distributed-systems.html">
    <link rel="next" href="addressing-fault-tolerance-and-high-availability-for-messages.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">Building Resilient Messaging Applications with ActiveMQ Artemis and OpenShift</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/REPLACEREPONAME/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="amq-connection-distribution" data-version="1.0.0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Building Resilient Messaging Applications with ActiveMQ Artemis and OpenShift</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/deploying-activemq-artemis-on-openshift.html">Deploying ActiveMQ Artemis on OpenShift</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/introduction-to-openshift-for-messaging-applications.html">Introduction to OpenShift for messaging applications</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/understanding-activemq-artemis-on-openshift.html">Understanding ActiveMQ Artemis on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/using-the-activemq-artemis-operator.html">Using the ActiveMQ Artemis Operator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/custom-resource-definitions-crds-for-artemis.html">Custom Resource Definitions (CRDs) for Artemis</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/configuring-persistent-storage-for-artemis.html">Configuring persistent storage for Artemis</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/scaling-artemis-brokers-on-openshift.html">Scaling Artemis brokers on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/monitoring-artemis-instances-on-openshift.html">Monitoring Artemis instances on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/hands-on-lab-deploying-a-highly-available-activemq-artemis-cluster-on-openshift.html">Hands-on Lab: Deploying a highly available ActiveMQ Artemis cluster on OpenShift</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="message-distribution-issues.html">Message distribution issues</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="understanding-distributed-messaging-patterns.html">Understanding distributed messaging patterns</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="load-balancing-messages-across-consumers.html">Load balancing messages across consumers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="message-routing-strategies-and-challenges.html">Message routing strategies and challenges</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="consumer-groups-and-shared-subscriptions.html">Consumer groups and shared subscriptions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ensuring-message-ordering-in-distributed-systems.html">Ensuring message ordering in distributed systems</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="handling-message-durability-and-reliability.html">Handling message durability and reliability</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="addressing-fault-tolerance-and-high-availability-for-messages.html">Addressing fault tolerance and high availability for messages</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../client-side-solution/client-side-solution.html">Client Side Solution</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-solution/client-side-connection-management-and-pooling.html">Client-side connection management and pooling</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-solution/implementing-client-failover-mechanisms.html">Implementing client failover mechanisms</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-solution/client-side-load-balancing-for-message-consumption.html">Client-side load balancing for message consumption</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-solution/message-acknowledgment-patterns-auto_acknowledge-client_acknowledge.html">Message acknowledgment patterns (AUTO_ACKNOWLEDGE, CLIENT_ACKNOWLEDGE)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-solution/transaction-management-for-message-producers-and-consumers.html">Transaction management for message producers and consumers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-solution/best-practices-for-client-integration-with-distributed-brokers.html">Best practices for client integration with distributed brokers</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../quarkus-example/quarkus-example.html">Quarkus Example</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/integrating-jmsamqp-clients-with-quarkus.html">Integrating JMS/AMQP clients with Quarkus</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/configuring-quarkus-for-activemq-artemis-connectivity.html">Configuring Quarkus for ActiveMQ Artemis connectivity</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/implementing-message-producers-in-quarkus.html">Implementing message producers in Quarkus</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/implementing-message-consumers-in-quarkus.html">Implementing message consumers in Quarkus</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/reactive-messaging-with-quarkus-and-artemis.html">Reactive messaging with Quarkus and Artemis</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/deploying-quarkus-messaging-applications-on-openshift.html">Deploying Quarkus messaging applications on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/hands-on-lab-developing-a-quarkus-microservice-with-distributed-messaging.html">Hands-on Lab: Developing a Quarkus microservice with distributed messaging</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../spring-boot-example/spring-boot-example.html">Spring Boot Example</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/integrating-jmsamqp-clients-with-spring-boot.html">Integrating JMS/AMQP clients with Spring Boot</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/configuring-spring-boot-for-activemq-artemis-connectivity.html">Configuring Spring Boot for ActiveMQ Artemis connectivity</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/using-spring-jmsamqp-templates-for-messaging.html">Using Spring JMS/AMQP templates for messaging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/implementing-message-producers-in-spring-boot.html">Implementing message producers in Spring Boot</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/implementing-message-consumers-in-spring-boot.html">Implementing message consumers in Spring Boot</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/configuring-listener-containers-and-concurrency.html">Configuring listener containers and concurrency</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/deploying-spring-boot-messaging-applications-on-openshift.html">Deploying Spring Boot messaging applications on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/hands-on-lab-developing-a-spring-boot-microservice-with-distributed-messaging.html">Hands-on Lab: Developing a Spring Boot microservice with distributed messaging</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Building Resilient Messaging Applications with ActiveMQ Artemis and OpenShift</span>
    <span class="version">1.0.0</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Building Resilient Messaging Applications with ActiveMQ Artemis and OpenShift</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1.0.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Building Resilient Messaging Applications with ActiveMQ Artemis and OpenShift</a></li>
    <li><a href="message-distribution-issues.html">Message distribution issues</a></li>
    <li><a href="handling-message-durability-and-reliability.html">Handling message durability and reliability</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Handling message durability and reliability</h1>
<h1 id="_handling_message_durability_and_reliability" class="sect0"><a class="anchor" href="#_handling_message_durability_and_reliability"></a>Handling Message Durability and Reliability</h1>
<div class="paragraph">
<p>In distributed messaging systems, ensuring that messages are not lost and are processed correctly is paramount. This section delves into the critical concepts of message durability and reliability, explaining how ActiveMQ Artemis and its clients can be configured to achieve these guarantees.</p>
</div>
<div class="sect1">
<h2 id="_understanding_message_durability"><a class="anchor" href="#_understanding_message_durability"></a>Understanding Message Durability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Message durability refers to the ability of a message to survive a broker restart. A durable message is persisted to storage by the messaging broker, meaning that even if the broker crashes or is shut down, the message will be available when the broker comes back online.</p>
</div>
<div class="paragraph">
<p>When a message is sent to an ActiveMQ Artemis broker, its durability depends on two primary factors:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>The message&#8217;s persistence setting:</strong> Messages can be marked as persistent or non-persistent by the producer. Persistent messages are candidates for durability.</p>
</li>
<li>
<p><strong>The address/queue&#8217;s persistence setting:</strong> For a persistent message to be truly durable, the queue or address it is sent to must also be configured to be persistent.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_how_activemq_artemis_ensures_durability"><a class="anchor" href="#_how_activemq_artemis_ensures_durability"></a>How ActiveMQ Artemis Ensures Durability</h3>
<div class="paragraph">
<p>ActiveMQ Artemis achieves message durability primarily through its <strong>journal</strong>. The journal is a high-performance write-ahead log that stores messages and other broker state changes to disk.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Persistent Messages:</strong> When a producer sends a persistent message, Artemis writes the message data to its journal <strong>before</strong> acknowledging receipt to the producer. This ensures that the message is safely stored on disk.</p>
</li>
<li>
<p><strong>Persistent Addresses/Queues:</strong> When an address or queue is configured as persistent, any persistent messages destined for it will be written to the journal. Non-persistent addresses/queues, even if receiving persistent messages, will not guarantee their durability beyond a broker restart (though the broker might hold them in memory until then).</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_persistence_in_activemq_artemis"><a class="anchor" href="#_configuring_persistence_in_activemq_artemis"></a>Configuring Persistence in ActiveMQ Artemis</h3>
<div class="paragraph">
<p>To enable message durability, you must ensure your ActiveMQ Artemis broker and its configurations are set up for persistence.</p>
</div>
<div class="listingblock">
<div class="title">Example: <code>broker.xml</code> Persistence Configuration</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;configuration&gt;
   &lt;core name="activemq"&gt;
      &lt;!-- ... other core configurations ... --&gt;

      &lt;!-- Configure journal settings --&gt;
      &lt;journal-type&gt;NIO&lt;/journal-type&gt;
      &lt;journal-directory&gt;./data/journal&lt;/journal-directory&gt;
      &lt;bindings-directory&gt;./data/bindings&lt;/bindings-directory&gt;
      &lt;large-messages-directory&gt;./data/large-messages&lt;/large-messages-directory&gt;

      &lt;!-- Enable persistence for addresses by default, or explicitly per address --&gt;
      &lt;addresses&gt;
         &lt;address name="my.durable.queue"&gt;
            &lt;anycast&gt;
               &lt;queue name="my.durable.queue" durable="true"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>
            &lt;/anycast&gt;
         &lt;/address&gt;
         &lt;address name="my.another.durable.address"&gt;
            &lt;multicast&gt;
               &lt;queue name="my.another.durable.address" durable="true"/&gt; <i class="conum" data-value="2"></i><b>(2)</b>
            &lt;/multicast&gt;
         &lt;/address&gt;
         &lt;!-- Example of a non-durable queue --&gt;
         &lt;address name="my.non.durable.queue"&gt;
            &lt;anycast&gt;
               &lt;queue name="my.non.durable.queue" durable="false"/&gt;
            &lt;/anycast&gt;
         &lt;/address&gt;
      &lt;/addresses&gt;
   &lt;/core&gt;
&lt;/configuration&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>durable="true"</code> ensures the queue will persist messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>For multicast, the subscription queue would typically be durable.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For clients, producers explicitly mark messages as persistent. For example, in JMS:</p>
</div>
<div class="listingblock">
<div class="title">Example: Sending a persistent JMS message</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Assume 'session' is a JMS Session and 'producer' is a MessageProducer
TextMessage message = session.createTextMessage("This is a durable message!");
producer.setDeliveryMode(DeliveryMode.PERSISTENT); // Mark message as persistent
producer.send(message);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Performance considerations: Enabling durability involves disk I/O, which can impact message throughput and latency compared to non-persistent messaging. It&#8217;s a trade-off between performance and guaranteed delivery.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_understanding_message_reliability"><a class="anchor" href="#_understanding_message_reliability"></a>Understanding Message Reliability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Message reliability extends beyond durability, encompassing the guarantee that a message is delivered to its intended recipient <strong>at least once</strong>, and often <strong>exactly once</strong>, without loss or duplication, through the entire lifecycle from producer to consumer. Reliability addresses various potential failure points, including network issues, broker crashes, and consumer application failures.</p>
</div>
<div class="paragraph">
<p>Key aspects of achieving message reliability include:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Producer-Side Reliability:</strong> Ensuring messages sent by the producer reach the broker.</p>
</li>
<li>
<p><strong>Broker-Side Reliability:</strong> Ensuring messages are safely stored and managed by the broker.</p>
</li>
<li>
<p><strong>Consumer-Side Reliability:</strong> Ensuring messages are successfully processed by the consumer.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_1_producer_side_reliability"><a class="anchor" href="#_1_producer_side_reliability"></a>1. Producer-Side Reliability</h3>
<div class="paragraph">
<p>Producers need mechanisms to confirm that the broker has received and persisted a message.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Synchronous Sends:</strong> The simplest way to ensure producer reliability is to use synchronous sends. The producer blocks until it receives an acknowledgment from the broker that the message has been processed (e.g., persisted). This offers strong guarantees but reduces throughput.</p>
</li>
<li>
<p><strong>Asynchronous Sends with Callbacks:</strong> For higher throughput, producers can send messages asynchronously and use callbacks to handle acknowledgments or errors from the broker.</p>
</li>
<li>
<p><strong>Transactions:</strong> Producers can send multiple messages within a transaction. The messages are only committed to the broker&#8217;s persistent store (and made visible to consumers) when the transaction is committed. If the transaction rolls back, none of the messages are committed.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Example: JMS Producer Transaction</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Assume 'connection' is a JMS Connection
Session session = connection.createSession(true, Session.SESSION_TRANSACTED); // Create a transactional session
MessageProducer producer = session.createProducer(myDurableQueue);

try {
    TextMessage message1 = session.createTextMessage("Transaction message 1");
    producer.send(message1);

    TextMessage message2 = session.createTextMessage("Transaction message 2");
    producer.send(message2);

    session.commit(); // Commit the transaction
    System.out.println("Messages committed successfully.");
} catch (JMSException e) {
    session.rollback(); // Rollback on error
    System.err.println("Transaction rolled back: " + e.getMessage());
} finally {
    if (session != null) {
        session.close();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_broker_side_reliability"><a class="anchor" href="#_2_broker_side_reliability"></a>2. Broker-Side Reliability</h3>
<div class="paragraph">
<p>Beyond message durability (persistence), brokers ensure reliability through:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>High Availability (HA):</strong> Using shared storage or replication, ActiveMQ Artemis clusters can failover seamlessly, ensuring that messages are always accessible even if a broker node fails. This is crucial for avoiding service interruptions and message loss during node failures. (Covered in detail in "Addressing fault tolerance and high availability for messages").</p>
</li>
<li>
<p><strong>Message Expiry and Dead Letter Queues (DLQ):</strong> Messages can have an expiry time. If a message expires before it&#8217;s consumed, it can be automatically moved to a Dead Letter Queue (DLQ) rather than being silently discarded. This ensures that potentially problematic messages are not lost but quarantined for investigation.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_3_consumer_side_reliability"><a class="anchor" href="#_3_consumer_side_reliability"></a>3. Consumer-Side Reliability</h3>
<div class="paragraph">
<p>The consumer plays a critical role in message reliability, primarily through its acknowledgment mechanism.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Message Acknowledgment Patterns:</strong> This is how a consumer informs the broker that it has successfully received and processed a message. Until a message is acknowledged, the broker typically considers it <strong>unacked</strong> and will redeliver it under certain circumstances (e.g., consumer disconnects before ack).</p>
</li>
<li>
<p><code>AUTO_ACKNOWLEDGE</code>: The session automatically acknowledges a message when it receives it (or finishes processing it in some configurations). This is the simplest but offers the weakest reliability guarantees, as messages might be lost if the consumer fails after receiving but before processing.</p>
</li>
<li>
<p><code>CLIENT_ACKNOWLEDGE</code>: The consumer application explicitly calls <code>message.acknowledge()</code> on the message object after it has successfully processed the message. This provides strong reliability as the message is only marked as consumed once the application logic is complete. If the application fails before calling <code>acknowledge()</code>, the message will be redelivered.</p>
</li>
<li>
<p><code>DUPS_OK_ACKNOWLEDGE</code>: Acknowledges messages lazily, batching acknowledgments. This can improve performance but may result in duplicate messages being delivered if the consumer or broker fails before a batch of acknowledgments is sent. Not recommended when "exactly once" processing is required.</p>
</li>
<li>
<p><code>SESSION_TRANSACTED</code>: Messages are consumed within a transaction. The <code>session.commit()</code> operation acknowledges all messages received within the transaction, and <code>session.rollback()</code> causes them to be redelivered. This offers the strongest "exactly once" processing guarantees when combined with producer transactions.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Example: JMS Consumer with <code>CLIENT_ACKNOWLEDGE</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Assume 'connection' is a JMS Connection
Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE); // Create a non-transactional, client-ack session
MessageConsumer consumer = session.createConsumer(myDurableQueue);

consumer.setMessageListener(message -&gt; {
    try {
        if (message instanceof TextMessage) {
            TextMessage textMessage = (TextMessage) message;
            System.out.println("Received: " + textMessage.getText());
            // Simulate processing
            // if (Math.random() &gt; 0.8) { // Simulate an occasional processing failure
            //     throw new RuntimeException("Simulated processing error!");
            // }

            message.acknowledge(); // Explicitly acknowledge the message after successful processing
            System.out.println("Message acknowledged.");
        }
    } catch (Exception e) {
        System.err.println("Error processing message: " + e.getMessage());
        // Do NOT acknowledge the message. It will be redelivered by the broker.
        // Or, move to DLQ if redelivery count exceeds threshold.
    }
});
connection.start();</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Redelivery Policies:</strong> ActiveMQ Artemis allows configuring redelivery policies for queues. This includes:</p>
</li>
<li>
<p>The maximum number of times a message will be redelivered.</p>
</li>
<li>
<p>A delay before redelivery.</p>
</li>
<li>
<p>Behavior after maximum redeliveries (e.g., move to DLQ).
These policies help prevent "poison pill" messages from perpetually blocking a queue.</p>
</li>
<li>
<p><strong>Dead Letter Queues (DLQ):</strong> As mentioned earlier, messages that fail to be processed after multiple redelivery attempts can be moved to a DLQ for manual inspection and resolution. This prevents them from continuously consuming resources or blocking other messages.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_hands_on_lab_configuring_activemq_artemis_for_durable_and_reliable_messaging"><a class="anchor" href="#_hands_on_lab_configuring_activemq_artemis_for_durable_and_reliable_messaging"></a>Hands-on Lab: Configuring ActiveMQ Artemis for Durable and Reliable Messaging</h4>
<div class="paragraph">
<p>In this lab, you will configure an ActiveMQ Artemis broker and a simple client to demonstrate message durability and client-side reliability.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>An ActiveMQ Artemis broker (standalone or deployed via Operator on OpenShift). For simplicity, a local standalone instance is sufficient.</p>
</li>
<li>
<p>A Java Development Kit (JDK).</p>
</li>
<li>
<p>Maven or Gradle for building the client.</p>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Steps</div>
<ol class="arabic">
<li>
<p><strong>Configure ActiveMQ Artemis for Persistence:</strong></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Locate your <code>broker.xml</code> configuration file (usually in <code>ARTEMIS_HOME/etc/broker.xml</code>).</p>
</li>
<li>
<p>Ensure the <code>&lt;journal-directory&gt;</code> and related journal settings are present and point to valid directories.</p>
</li>
<li>
<p>Add a durable queue definition under <code>&lt;addresses&gt;</code> for an address named <code>my.durable.queue</code>:
[source,xml]
----
&lt;address name="my.durable.queue"&gt;
   &lt;anycast&gt;
      &lt;queue name="my.durable.queue" durable="true"/&gt;
   &lt;/anycast&gt;
&lt;/address&gt;
----</p>
</li>
<li>
<p>Start the ActiveMQ Artemis broker.</p>
</li>
</ol>
</div>
</li>
<li>
<p><strong>Develop a Java Client with Producer and Consumer:</strong></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Create a new Maven or Gradle project.</p>
</li>
<li>
<p>Add the ActiveMQ Artemis JMS client dependency (e.g., for Maven):
[source,xml]
----
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
    &lt;artifactId&gt;artemis-jms-client&lt;/artifactId&gt;
    &lt;version&gt;2.31.0&lt;/version&gt; &lt;!-- Use your broker&#8217;s version or compatible -&#8594;
&lt;/dependency&gt;
----</p>
</li>
<li>
<p>Implement a <code>DurableMessageProducerConsumer</code> class:</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Example: DurableMessageProducerConsumer.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory;

import javax.jms.*;

public class DurableMessageProducerConsumer {

    private static final String BROKER_URL = "tcp://localhost:61616";
    private static final String QUEUE_NAME = "my.durable.queue";

    public static void main(String[] args) throws Exception {
        Connection connection = null;
        try {
            ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(BROKER_URL);
            connection = connectionFactory.createConnection();
            connection.start(); // Start the connection to allow message flow

            // === Producer ===
            Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // Non-transacted, auto-ack for producer
            Queue queue = producerSession.createQueue(QUEUE_NAME);
            MessageProducer producer = producerSession.createProducer(queue);
            producer.setDeliveryMode(DeliveryMode.PERSISTENT); // Important for durability

            TextMessage message1 = producerSession.createTextMessage("Hello Durable Message 1");
            producer.send(message1);
            System.out.println("Sent: " + message1.getText());

            TextMessage message2 = producerSession.createTextMessage("Hello Durable Message 2");
            producer.send(message2);
            System.out.println("Sent: " + message2.getText());

            producerSession.close(); // Close producer session

            System.out.println("\nProducer finished sending messages. Now stopping broker to test durability...");
            // Simulate broker restart: You would manually stop the broker here.
            // For this lab, we'll continue, but imagine the broker restarts now.

            Thread.sleep(5000); // Give time to observe broker state if stopping manually

            // === Consumer ===
            System.out.println("Starting consumer to retrieve messages (possibly after broker restart)...");
            Session consumerSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE); // Non-transacted, client-ack
            MessageConsumer consumer = consumerSession.createConsumer(queue);

            consumer.setMessageListener(msg -&gt; {
                try {
                    if (msg instanceof TextMessage) {
                        TextMessage textMessage = (TextMessage) msg;
                        System.out.println("Consumer received: " + textMessage.getText());
                        // Simulate some processing time
                        Thread.sleep(100);
                        // Acknowledge the message ONLY after successful processing
                        textMessage.acknowledge();
                        System.out.println("Consumer acknowledged: " + textMessage.getText());
                    }
                } catch (JMSException e) {
                    System.err.println("JMS Exception in listener: " + e.getMessage());
                    // Do not acknowledge, message will be redelivered
                } catch (InterruptedException e) {
                    System.err.println("Interrupted Exception in listener: " + e.getMessage());
                    Thread.currentThread().interrupt();
                } catch (Exception e) {
                    System.err.println("Generic Exception in listener: " + e.getMessage());
                    // Do not acknowledge, message will be redelivered
                }
            });

            // Keep the consumer alive for some time
            Thread.sleep(10000);

            consumerSession.close();

        } finally {
            if (connection != null) {
                connection.close();
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Execute the Lab:</strong></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Start your ActiveMQ Artemis broker.</p>
</li>
<li>
<p>Run the <code>DurableMessageProducerConsumer</code> Java client.</p>
</li>
<li>
<p>Observe the producer sending messages.</p>
</li>
<li>
<p><strong>Crucial Durability Test:</strong> While the client is running (and messages have been sent), <strong>stop your ActiveMQ Artemis broker process</strong>. You will see the consumer stop receiving messages.</p>
</li>
<li>
<p>Now, <strong>restart your ActiveMQ Artemis broker</strong>.</p>
</li>
<li>
<p>The client&#8217;s consumer (which is still running or you can restart it) should now connect to the broker and <strong>receive the messages that were sent before the broker restart</strong>. This demonstrates durability.</p>
</li>
<li>
<p>Observe the consumer explicitly acknowledging each message. To test client-side reliability, you could comment out <code>textMessage.acknowledge();</code> and restart the consumer; you would see the messages being redelivered repeatedly.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>This lab provides a practical demonstration of how persistent messages sent to durable queues survive broker restarts, and how client acknowledgments ensure messages are only removed from the queue after successful processing.</p>
</div>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="ensuring-message-ordering-in-distributed-systems.html">Ensuring message ordering in distributed systems</a></span>
  <span class="next"><a href="addressing-fault-tolerance-and-high-availability-for-messages.html">Addressing fault tolerance and high availability for messages</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
