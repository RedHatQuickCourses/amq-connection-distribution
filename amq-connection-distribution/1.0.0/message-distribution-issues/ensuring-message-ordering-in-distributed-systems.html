<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Ensuring message ordering in distributed systems :: Building Resilient Messaging Applications with ActiveMQ Artemis and OpenShift</title>
    <link rel="prev" href="consumer-groups-and-shared-subscriptions.html">
    <link rel="next" href="handling-message-durability-and-reliability.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">Building Resilient Messaging Applications with ActiveMQ Artemis and OpenShift</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/REPLACEREPONAME/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="amq-connection-distribution" data-version="1.0.0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Building Resilient Messaging Applications with ActiveMQ Artemis and OpenShift</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/deploying-activemq-artemis-on-openshift.html">Deploying ActiveMQ Artemis on OpenShift</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/introduction-to-openshift-for-messaging-applications.html">Introduction to OpenShift for messaging applications</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/understanding-activemq-artemis-on-openshift.html">Understanding ActiveMQ Artemis on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/using-the-activemq-artemis-operator.html">Using the ActiveMQ Artemis Operator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/custom-resource-definitions-crds-for-artemis.html">Custom Resource Definitions (CRDs) for Artemis</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/configuring-persistent-storage-for-artemis.html">Configuring persistent storage for Artemis</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/scaling-artemis-brokers-on-openshift.html">Scaling Artemis brokers on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/monitoring-artemis-instances-on-openshift.html">Monitoring Artemis instances on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-activemq-artemis-on-openshift/hands-on-lab-deploying-a-highly-available-activemq-artemis-cluster-on-openshift.html">Hands-on Lab: Deploying a highly available ActiveMQ Artemis cluster on OpenShift</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="message-distribution-issues.html">Message distribution issues</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="understanding-distributed-messaging-patterns.html">Understanding distributed messaging patterns</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="load-balancing-messages-across-consumers.html">Load balancing messages across consumers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="message-routing-strategies-and-challenges.html">Message routing strategies and challenges</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="consumer-groups-and-shared-subscriptions.html">Consumer groups and shared subscriptions</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="ensuring-message-ordering-in-distributed-systems.html">Ensuring message ordering in distributed systems</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="handling-message-durability-and-reliability.html">Handling message durability and reliability</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="addressing-fault-tolerance-and-high-availability-for-messages.html">Addressing fault tolerance and high availability for messages</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../client-side-solution/client-side-solution.html">Client Side Solution</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-solution/client-side-connection-management-and-pooling.html">Client-side connection management and pooling</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-solution/implementing-client-failover-mechanisms.html">Implementing client failover mechanisms</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-solution/client-side-load-balancing-for-message-consumption.html">Client-side load balancing for message consumption</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-solution/message-acknowledgment-patterns-auto_acknowledge-client_acknowledge.html">Message acknowledgment patterns (AUTO_ACKNOWLEDGE, CLIENT_ACKNOWLEDGE)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-solution/transaction-management-for-message-producers-and-consumers.html">Transaction management for message producers and consumers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-solution/best-practices-for-client-integration-with-distributed-brokers.html">Best practices for client integration with distributed brokers</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../quarkus-example/quarkus-example.html">Quarkus Example</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/integrating-jmsamqp-clients-with-quarkus.html">Integrating JMS/AMQP clients with Quarkus</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/configuring-quarkus-for-activemq-artemis-connectivity.html">Configuring Quarkus for ActiveMQ Artemis connectivity</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/implementing-message-producers-in-quarkus.html">Implementing message producers in Quarkus</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/implementing-message-consumers-in-quarkus.html">Implementing message consumers in Quarkus</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/reactive-messaging-with-quarkus-and-artemis.html">Reactive messaging with Quarkus and Artemis</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/deploying-quarkus-messaging-applications-on-openshift.html">Deploying Quarkus messaging applications on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../quarkus-example/hands-on-lab-developing-a-quarkus-microservice-with-distributed-messaging.html">Hands-on Lab: Developing a Quarkus microservice with distributed messaging</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../spring-boot-example/spring-boot-example.html">Spring Boot Example</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/integrating-jmsamqp-clients-with-spring-boot.html">Integrating JMS/AMQP clients with Spring Boot</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/configuring-spring-boot-for-activemq-artemis-connectivity.html">Configuring Spring Boot for ActiveMQ Artemis connectivity</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/using-spring-jmsamqp-templates-for-messaging.html">Using Spring JMS/AMQP templates for messaging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/implementing-message-producers-in-spring-boot.html">Implementing message producers in Spring Boot</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/implementing-message-consumers-in-spring-boot.html">Implementing message consumers in Spring Boot</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/configuring-listener-containers-and-concurrency.html">Configuring listener containers and concurrency</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/deploying-spring-boot-messaging-applications-on-openshift.html">Deploying Spring Boot messaging applications on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-boot-example/hands-on-lab-developing-a-spring-boot-microservice-with-distributed-messaging.html">Hands-on Lab: Developing a Spring Boot microservice with distributed messaging</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Building Resilient Messaging Applications with ActiveMQ Artemis and OpenShift</span>
    <span class="version">1.0.0</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Building Resilient Messaging Applications with ActiveMQ Artemis and OpenShift</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1.0.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Building Resilient Messaging Applications with ActiveMQ Artemis and OpenShift</a></li>
    <li><a href="message-distribution-issues.html">Message distribution issues</a></li>
    <li><a href="ensuring-message-ordering-in-distributed-systems.html">Ensuring message ordering in distributed systems</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Ensuring message ordering in distributed systems</h1>
<h1 id="_ensuring_message_ordering_in_distributed_systems" class="sect0"><a class="anchor" href="#_ensuring_message_ordering_in_distributed_systems"></a>Ensuring Message Ordering in Distributed Systems</h1>
<div class="paragraph">
<p>Ensuring that messages are processed in the exact order they were produced is a critical requirement for many enterprise applications, especially in domains like financial transactions, event streaming, and state management. In distributed messaging systems like those built with ActiveMQ Artemis, maintaining this order can be challenging due to inherent complexities like network latency, concurrency, and multiple producers or consumers.</p>
</div>
<div class="sect1">
<h2 id="_the_importance_of_message_ordering"><a class="anchor" href="#_the_importance_of_message_ordering"></a>The Importance of Message Ordering</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Consider a scenario where a user updates their profile. This might involve a sequence of messages: <code>UserProfileCreated</code>, <code>EmailChanged</code>, <code>AddressChanged</code>. If these messages are processed out of order, the system&#8217;s state could become inconsistent (e.g., the <code>EmailChanged</code> event is processed before <code>UserProfileCreated</code>, leading to an error or an outdated email being displayed).
Other examples include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Financial Transactions</strong>: Debits and credits must be applied in the correct sequence.</p>
</li>
<li>
<p><strong>Event Sourcing</strong>: Events that build up an aggregate&#8217;s state must be replayed in order.</p>
</li>
<li>
<p><strong>Log Processing</strong>: Log entries need to be processed chronologically for accurate analysis.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Missing or incorrect message ordering can lead to data corruption, inconsistent states, and incorrect business logic execution.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_challenges_in_distributed_systems"><a class="anchor" href="#_challenges_in_distributed_systems"></a>Challenges in Distributed Systems</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Achieving strict message ordering in a distributed environment is complex due to several factors:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Multiple Producers</strong>: If multiple producers send messages to the same destination concurrently, there&#8217;s no inherent guarantee that the messaging system will receive them in the order they were sent from their respective sources, nor that it will deliver them in that order to consumers.</p>
</li>
<li>
<p><strong>Network Latency</strong>: Messages can travel through different network paths, experiencing varying latencies, leading to them arriving at the broker or consumer out of sequence.</p>
</li>
<li>
<p><strong>Asynchronous Processing</strong>: Messaging systems inherently decouple producers and consumers, leading to asynchronous processing where messages might be queued and delivered independently.</p>
</li>
<li>
<p><strong>Consumer Concurrency</strong>: When multiple consumers process messages from the same queue, each consumer picks messages independently. Without specific mechanisms, there&#8217;s no guarantee about the relative order of processing across these consumers.</p>
</li>
<li>
<p><strong>Broker Clustering and Failover</strong>: In a clustered environment, messages might be routed through different broker nodes or redistributed during failover events, which can disrupt a strict ordering guarantee if not properly managed.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_strategies_for_ensuring_message_ordering"><a class="anchor" href="#_strategies_for_ensuring_message_ordering"></a>Strategies for Ensuring Message Ordering</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ActiveMQ Artemis provides robust features to help manage and ensure message ordering, especially through its concept of <strong>Message Groups</strong>. Other general strategies also play a role.</p>
</div>
<div class="sect2">
<h3 id="_message_grouping_activemq_artemis"><a class="anchor" href="#_message_grouping_activemq_artemis"></a>Message Grouping (ActiveMQ Artemis)</h3>
<div class="paragraph">
<p>Message Groups are the primary mechanism in ActiveMQ Artemis for ensuring that all messages belonging to a logical group are processed sequentially by <strong>a single consumer</strong>. This is crucial when a set of related messages must be processed in a specific order.</p>
</div>
<div class="paragraph">
<p>How it works:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong><code>JMSXGroupID</code> Property</strong>: Producers set the <code>JMSXGroupID</code> property on messages. All messages with the same <code>JMSXGroupID</code> are considered part of the same group.</p>
</li>
<li>
<p><strong>Broker Routing</strong>: When the broker receives a message with a <code>JMSXGroupID</code>, it attempts to route it to the consumer that is currently processing messages for that specific group.</p>
</li>
<li>
<p><strong>Sticky Consumer</strong>: Once a consumer receives a message from a particular <code>JMSXGroupID</code>, all subsequent messages with that <strong>same ID</strong> will be delivered exclusively to <strong>that same consumer</strong> until the group is closed (by sending a message with <code>JMSXGroupSeq = -1</code>) or the consumer disconnects. This "stickiness" ensures sequential processing within the group.</p>
</li>
<li>
<p><strong><code>JMSXGroupSeq</code> Property</strong>: Optionally, producers can also set <code>JMSXGroupSeq</code> to provide an explicit sequence number within the group. This can be useful for detecting missing messages or reordering if a consumer needs to manage out-of-order delivery within the group (e.g., if a message arrives early, the consumer might buffer it until the preceding message in the sequence arrives). A <code>JMSXGroupSeq</code> of -1 indicates the end of a group.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Advantages of Message Groups:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensures strict ordering for logically related messages.</p>
</li>
<li>
<p>Allows horizontal scaling of consumers: different groups can be processed concurrently by different consumers, while messages <strong>within</strong> a group are processed sequentially.</p>
</li>
<li>
<p>Simplifies client-side logic for ordering specific sequences by offloading the routing to the broker.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Example: Sending Messages with a Message Group ID</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.jms.*;
import org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory;

public class GroupedMessageProducer {

    public static void main(String[] args) throws JMSException {
        Connection connection = null;
        Session session = null;
        try {
            ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:61616");
            connection = connectionFactory.createConnection();
            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // No transactions
            Queue queue = session.createQueue("myQueue");
            MessageProducer producer = session.createProducer(queue);

            String groupId = "order_12345"; // All messages for this order will be grouped

            // Message 1: Item Added
            TextMessage message1 = session.createTextMessage("Order 12345 - Item Added: Laptop");
            message1.setStringProperty("JMSXGroupID", groupId);
            message1.setIntProperty("JMSXGroupSeq", 1); // Sequence within the group
            producer.send(message1);
            System.out.println("Sent: " + message1.getText() + " (Group: " + groupId + ", Seq: 1)");

            // Message 2: Payment Processed
            TextMessage message2 = session.createTextMessage("Order 12345 - Payment Processed");
            message2.setStringProperty("JMSXGroupID", groupId);
            message2.setIntProperty("JMSXGroupSeq", 2);
            producer.send(message2);
            System.out.println("Sent: " + message2.getText() + " (Group: " + groupId + ", Seq: 2)");

            // Message 3: Order Shipped
            TextMessage message3 = session.createTextMessage("Order 12345 - Order Shipped");
            message3.setStringProperty("JMSXGroupID", groupId);
            message3.setIntProperty("JMSXGroupSeq", 3);
            producer.send(message3);
            System.out.println("Sent: " + message3.getText() + " (Group: " + groupId + ", Seq: 3)");

            // Optionally, indicate end of group by setting JMSXGroupSeq to -1
            // This releases the consumer and allows it to process other groups
            TextMessage endGroupMessage = session.createTextMessage("Order 12345 - Group End");
            endGroupMessage.setStringProperty("JMSXGroupID", groupId);
            endGroupMessage.setIntProperty("JMSXGroupSeq", -1); // Signifies end of group
            producer.send(endGroupMessage);
            System.out.println("Sent: " + endGroupMessage.getText() + " (Group: " + groupId + ", Seq: -1)");


        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (session != null) session.close();
            if (connection != null) connection.close();
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example: Consuming Messages with a Message Group ID (Consumer will receive messages in order)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.jms.*;
import org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory;

public class GroupedMessageConsumer {

    public static void main(String[] args) throws JMSException {
        Connection connection = null;
        Session session = null;
        try {
            ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:61616");
            connection = connectionFactory.createConnection();
            connection.start(); // Must start connection for message delivery
            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // No transactions
            Queue queue = session.createQueue("myQueue");
            MessageConsumer consumer = session.createConsumer(queue);

            System.out.println("Waiting for messages...");

            // Loop indefinitely to receive messages
            while (true) {
                Message message = consumer.receive(5000); // Wait up to 5 seconds for a message
                if (message instanceof TextMessage textMessage) {
                    String groupId = textMessage.getStringProperty("JMSXGroupID");
                    int groupSeq = textMessage.getIntProperty("JMSXGroupSeq");
                    System.out.println("Received: " + textMessage.getText() +
                            " (Group: " + groupId + ", Seq: " + groupSeq + ")");

                    // Acknowledge the message if session is not AUTO_ACKNOWLEDGE
                    // message.acknowledge();

                    if (groupSeq == -1) {
                        System.out.println("End of group '" + groupId + "' detected.");
                        // Consumer is now free to take on another group
                    }
                } else if (message != null) {
                    System.out.println("Received non-text message: " + message.getClass().getName());
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (session != null) session.close();
            if (connection != null) connection.close();
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using message groups, if the consumer handling a specific group disconnects (e.g., due to a crash or redeployment), the broker will automatically reassign that group to another available consumer from the same consumer group. The next message for that group will be delivered to the new consumer, ensuring continuity of ordered processing. This makes message groups highly resilient.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_exclusive_consumers"><a class="anchor" href="#_exclusive_consumers"></a>Exclusive Consumers</h3>
<div class="paragraph">
<p>An exclusive consumer is a special type of consumer that ensures only <strong>one</strong> consumer instance can ever consume from a specific queue at any given time. If multiple consumers attempt to connect to an exclusive queue, only the first one succeeds, and the others remain blocked or are rejected until the exclusive consumer disconnects.</p>
</div>
<div class="paragraph">
<p>While this guarantees strict FIFO ordering for all messages on that queue, it severely limits scalability, as only one consumer can ever process messages. It&#8217;s suitable for scenarios with low message throughput or where absolute strict ordering for <strong>all</strong> messages on a queue is paramount, and horizontal scalability for consumers is not a priority.</p>
</div>
<div class="paragraph">
<p>To configure an exclusive consumer for a queue, you typically set the <code>exclusive</code> property on the queue to <code>true</code> in ActiveMQ Artemis configuration, or a client can declare an exclusive consumer using specific JMS properties or AMQP capabilities.</p>
</div>
</div>
<div class="sect2">
<h3 id="_partitioning_sharding"><a class="anchor" href="#_partitioning_sharding"></a>Partitioning / Sharding</h3>
<div class="paragraph">
<p>This is a general architectural pattern that complements message grouping. Instead of relying solely on the messaging system to enforce a strict global order, you design your application to partition related messages into distinct queues or topic partitions.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Mechanism</strong>: A "partition key" (e.g., <code>userId</code>, <code>orderId</code>) is derived from the message content. Messages with the same partition key are always sent to the <strong>same</strong> specific queue or topic partition.</p>
</li>
<li>
<p><strong>Consumer Mapping</strong>: A dedicated consumer or a set of consumers is responsible for processing messages from a particular partition.</p>
</li>
<li>
<p><strong>ActiveMQ Artemis Relevance</strong>: While Artemis queues don&#8217;t have built-in "partitions" like some other messaging systems (e.g., Kafka), you can achieve a similar effect by creating multiple physical queues (e.g., <code>user-updates-partition-0</code>, <code>user-updates-partition-1</code>) and using a client-side routing logic to send messages to the appropriate queue based on a message key. Message groups then ensure ordering <strong>within</strong> these "logical partitions" if you have multiple consumers for each. This allows parallel processing of different partitions while maintaining order within each partition.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_producer_side_sequencing_and_client_coordination"><a class="anchor" href="#_producer_side_sequencing_and_client_coordination"></a>Producer-Side Sequencing and Client Coordination</h3>
<div class="paragraph">
<p>Producers play a vital role in enabling ordering:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Sequential Sending</strong>: The simplest way to ensure a sequence of messages is delivered in order is for a <strong>single producer</strong> to send them sequentially to the broker within a single session or transaction. This works best when the producer itself has control over the ordering and can guarantee messages are sent one after another.</p>
</li>
<li>
<p><strong>Client-Side Batching/Ordering</strong>: For very specific requirements, producers might internally batch messages or assign client-side sequence numbers before sending them. This can be combined with <code>JMSXGroupSeq</code> to provide an additional layer of ordering or for recovery scenarios where the consumer needs to validate the sequence.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_consumer_side_reordering_less_common_for_strict_order"><a class="anchor" href="#_consumer_side_reordering_less_common_for_strict_order"></a>Consumer-Side Reordering (Less Common for Strict Order)</h3>
<div class="paragraph">
<p>In some less stringent scenarios, consumers might receive messages out of order and attempt to reorder them based on timestamps or sequence numbers embedded in the message payload.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Mechanism</strong>: Messages contain an explicit sequence number or a timestamp in their payload. The consumer maintains a buffer, receiving messages, reordering them, and only processing them when the correct sequence is established.</p>
</li>
<li>
<p><strong>Challenges</strong>:</p>
</li>
<li>
<p><strong>Complexity</strong>: Adds significant complexity to consumer logic, requiring state management for received and expected messages.</p>
</li>
<li>
<p><strong>Missing Messages</strong>: What happens if a message is lost? The consumer might get stuck indefinitely waiting for a missing sequence number.</p>
</li>
<li>
<p><strong>Latency</strong>: Introduces processing delay as messages are buffered.</p>
</li>
<li>
<p><strong>Resource Consumption</strong>: Buffering messages can consume significant memory or disk resources.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This approach is generally less desirable for <strong>strict</strong> ordering guarantees compared to broker-assisted mechanisms like Message Groups, but can be a fallback for "eventual ordering" or specific recovery patterns where some out-of-order processing is tolerable.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_best_practices_for_ensuring_message_ordering"><a class="anchor" href="#_best_practices_for_ensuring_message_ordering"></a>Best Practices for Ensuring Message Ordering</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Identify Critical Sequences</strong>: Clearly define which message flows absolutely require strict ordering. Not all messages need it, and enforcing it unnecessarily can reduce scalability and add complexity.</p>
</li>
<li>
<p><strong>Leverage Message Groups (ActiveMQ Artemis)</strong>: For related sequences of messages that need to be processed by a single consumer, <code>JMSXGroupID</code> is the most effective, scalable, and resilient solution provided by ActiveMQ Artemis.</p>
</li>
<li>
<p><strong>Use <code>JMSXGroupSeq</code> Judiciously</strong>: While <code>JMSXGroupID</code> handles the "sticky consumer" aspect, <code>JMSXGroupSeq</code> can provide additional robustness, especially for recovery or auditing, by giving explicit sequence numbers within a group. This allows a consumer to detect gaps or unexpected sequences.</p>
</li>
<li>
<p><strong>Consider Partitioning Architecturally</strong>: For very high-throughput scenarios where a single queue with message groups might become a bottleneck, consider architecturally partitioning your data into multiple queues or destinations based on a key (e.g., <code>tenantId</code>, <code>userId</code>) and then applying message groups <strong>within</strong> those partitions.</p>
</li>
<li>
<p><strong>Design Idempotent Consumers</strong>: Even with ordering guarantees, network issues, or consumer failures can lead to duplicates or out-of-order retries (e.g., if a message is redelivered). Design consumers to be idempotent so that reprocessing the same message multiple times or slightly out of order does not lead to incorrect state changes. This provides a crucial safety net.</p>
</li>
<li>
<p><strong>Avoid Global Ordering</strong>: Trying to enforce a strict global order across <strong>all</strong> messages in a highly distributed system is often impractical and a significant performance bottleneck. Focus on ordering <strong>within specific logical groups</strong> or partitions, as this provides a balance between strictness and scalability.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By strategically applying these techniques, particularly ActiveMQ Artemis&#8217;s powerful Message Group feature, you can build resilient messaging applications that maintain critical message order while still achieving high availability and scalability on OpenShift.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="consumer-groups-and-shared-subscriptions.html">Consumer groups and shared subscriptions</a></span>
  <span class="next"><a href="handling-message-durability-and-reliability.html">Handling message durability and reliability</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
