<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Developing a producer for Point-to-Point messaging :: ActiveMQ Artemis Clustering and High Availability</title>
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">ActiveMQ Artemis Clustering and High Availability</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/REPLACEREPONAME/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="amq-connection-distribution" data-version="1.0.0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">ActiveMQ Artemis Clustering and High Availability</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../message-oriented-middleware-introduction/message-oriented-middleware-introduction.html">Message Oriented Middleware Introduction</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../message-oriented-middleware-introduction/role-of-mom-in-distributed-systems.html">Role of MOM in distributed systems</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../message-oriented-middleware-introduction/benefits-of-asynchronous-communication.html">Benefits of asynchronous communication</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../message-oriented-middleware-introduction/ensuring-resilience-and-reliability-with-mom.html">Ensuring resilience and reliability with MOM</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../message-oriented-middleware-introduction/introduction-to-activemq-artemis.html">Introduction to ActiveMQ Artemis</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../message-oriented-middleware-introduction/key-features-and-architecture-of-activemq-artemis.html">Key features and architecture of ActiveMQ Artemis</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../challenges-with-clustered-brokers/challenges-with-clustered-brokers.html">Challenges with clustered brokers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../challenges-with-clustered-brokers/uneven-connection-distribution-across-cluster-nodes.html">Uneven connection distribution across cluster nodes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../challenges-with-clustered-brokers/bottlenecks-from-single-connection-points.html">Bottlenecks from single connection points</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../challenges-with-clustered-brokers/overhead-and-impact-of-message-redistribution.html">Overhead and impact of message redistribution</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../challenges-with-clustered-brokers/reduced-cluster-throughput-in-specific-scenarios.html">Reduced cluster throughput in specific scenarios</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../challenges-with-clustered-brokers/disk-paging-issues-for-high-volume-queues.html">Disk paging issues for high-volume queues</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../solutions/solutions.html">Solutions</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions/activemq-artemis-clustering-overview.html">ActiveMQ Artemis clustering overview</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions/high-availability-ha-and-automatic-failover.html">High Availability (HA) and automatic failover</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions/server-side-message-load-balancing.html">Server-side message load balancing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions/scaling-with-competing-consumers.html">Scaling with competing consumers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions/deploying-activemq-artemis-on-openshift.html">Deploying ActiveMQ Artemis on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions/utilizing-the-red-hat-amq-operator.html">Utilizing the Red Hat AMQ Operator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions/configuring-activemqartemis-custom-resources-for-clustering.html">Configuring ActiveMQArtemis Custom Resources for clustering</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../code-examples/code-examples.html">Code Examples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../code-examples/developing-producer-applications-for-activemq-artemis.html">Developing producer applications for ActiveMQ Artemis</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../code-examples/developing-consumer-applications-for-activemq-artemis.html">Developing consumer applications for ActiveMQ Artemis</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../code-examples/connecting-clients-to-a-clustered-artemis-environment.html">Connecting clients to a clustered Artemis environment</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../code-examples/demonstrating-message-publishing-and-consumption-patterns.html">Demonstrating message publishing and consumption patterns</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">ActiveMQ Artemis Clustering and High Availability</span>
    <span class="version">1.0.0</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">ActiveMQ Artemis Clustering and High Availability</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1.0.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">ActiveMQ Artemis Clustering and High Availability</a></li>
    <li><a href="developing-a-producer-for-point-to-point-messaging.html">Developing a producer for Point-to-Point messaging</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Developing a producer for Point-to-Point messaging</h1>
<h1 id="_developing_a_producer_for_point_to_point_messaging" class="sect0"><a class="anchor" href="#_developing_a_producer_for_point_to_point_messaging"></a>Developing a Producer for Point-to-Point Messaging</h1>
<div class="paragraph">
<p>In Point-to-Point (PTP) messaging, a <strong>producer</strong> is the application component responsible for creating and sending messages to a specific queue. These messages are intended for a single consumer. This section will guide you through the process of developing a producer application that can send messages to a queue, demonstrating the fundamental concepts of PTP communication.</p>
</div>
<div class="sect1">
<h2 id="_the_role_of_a_ptp_producer"><a class="anchor" href="#_the_role_of_a_ptp_producer"></a>The Role of a PTP Producer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A PTP producer acts as the initiator of a message exchange. Its primary responsibilities include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Connecting to the Broker</strong>: Establishing a connection with the message broker, which acts as the intermediary for message transfer. This connection ensures reliable communication channels.</p>
</li>
<li>
<p><strong>Identifying the Destination</strong>: Specifying the target queue where the message should be sent. In the PTP model, this is a distinct, named queue.</p>
</li>
<li>
<p><strong>Constructing the Message</strong>: Creating the content of the message. This payload can be any form of data, such as plain text, structured JSON or XML, or even binary data.</p>
</li>
<li>
<p><strong>Sending the Message</strong>: Transmitting the message to the specified queue via the broker. The broker then takes responsibility for storing and delivering the message.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once a message is sent to a queue, the broker stores it until a consumer retrieves and processes it. This mechanism ensures strong decoupling between the producer and consumer, allowing them to operate independently and asynchronously; they do not need to be active simultaneously.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hands_on_lab_building_a_ptp_producer"><a class="anchor" href="#_hands_on_lab_building_a_ptp_producer"></a>Hands-on Lab: Building a PTP Producer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For this lab, we will simulate a simple scenario where a "task generator" acts as a producer, sending task messages to a queue. We&#8217;ll use Python for our example due to its readability and common usage in educational contexts.</p>
</div>
<div class="sect2">
<h3 id="_prerequisites"><a class="anchor" href="#_prerequisites"></a>Prerequisites</h3>
<div class="paragraph">
<p>Before you begin, ensure you have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A running message broker instance (e.g., RabbitMQ, ActiveMQ, Kafka). For the purpose of this generic example, we will assume a broker is accessible and you have its connection details (e.g., host, port). (This should have been set up in the "Setting up a basic message broker" step).</p>
</li>
<li>
<p>Python installed on your system.</p>
</li>
<li>
<p>A messaging client library installed for your chosen broker. <strong>Note: In a real scenario, you would install a specific client like <code>pika</code> for RabbitMQ, <code>kafka-python</code> for Kafka, etc. For our generic example, we&#8217;ll use a conceptual placeholder.</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s assume we&#8217;re using a conceptual <code>some_messaging_library</code> for our example to keep it generalized, but the underlying concepts apply directly to any real messaging system.</p>
</div>
</div>
<div class="sect2">
<h3 id="_step_1_initialize_your_project_directory"><a class="anchor" href="#_step_1_initialize_your_project_directory"></a>Step 1: Initialize Your Project Directory</h3>
<div class="paragraph">
<p>Create a new directory for your producer application and navigate into it using your terminal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">mkdir ptp-producer
cd ptp-producer</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_step_2_write_the_producer_code"><a class="anchor" href="#_step_2_write_the_producer_code"></a>Step 2: Write the Producer Code</h3>
<div class="paragraph">
<p>Create a file named <code>producer.py</code> within your <code>ptp-producer</code> directory and add the following Python code. This code will simulate connecting to a message broker, declaring a queue, and then sending a series of messages to that queue.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">import time
import json # To demonstrate structured messages

# In a real-world scenario, you would import a specific client library,
# e.g., import pika for RabbitMQ, or from kafka import KafkaProducer for Kafka.
# For this generic example, we'll use a placeholder to illustrate the concepts.

class MessageBrokerClient:
    """
    A conceptual placeholder class to simulate interaction with a message broker.
    In a real application, this would be replaced by an actual client library.
    """
    def __init__(self, host='localhost', port=5672):
        print(f"Connecting to message broker at {host}:{port}...")
        # Simulate connection establishment
        time.sleep(0.5)
        print("Connection established.")
        self.channel = self._create_channel() # Simulate a channel concept common in AMQP

    def _create_channel(self):
        print("Creating channel for communication...")
        time.sleep(0.2)
        return self._Channel()

    class _Channel:
        """
        A conceptual channel to simulate queue operations.
        """
        def queue_declare(self, queue_name, durable=True):
            print(f"Declared queue: '{queue_name}' (durable: {durable})")

        def basic_publish(self, exchange='', routing_key='', body=''):
            # In a real system, the broker would acknowledge receipt.
            # Here we print to console to show what's conceptually sent.
            print(f" [x] Sent '{body.decode('utf-8') if isinstance(body, bytes) else body}' to queue '{routing_key}'")

        def close(self):
            print("Channel closed.")

    def close(self):
        print("Connection gracefully closed.")

def main():
    queue_name = 'task_queue' # The name of our PTP queue

    # 1. Establish connection to the message broker
    #    Replace MessageBrokerClient with your actual broker client (e.g., pika.BlockingConnection)
    connection = MessageBrokerClient(host='localhost', port=5672)

    try:
        # 2. Get a channel from the connection.
        #    Channels provide a lightweight way to multiplex multiple operations over a single TCP connection.
        channel = connection.channel

        # 3. Declare the queue.
        #    This operation is idempotent: it will only create the queue if it doesn't exist.
        #    'durable=True' means the queue will survive a broker restart.
        channel.queue_declare(queue_name=queue_name, durable=True)

        # 4. Prepare and send messages
        for i in range(5):
            task_data = {
                "id": i + 1,
                "description": f"Process data chunk {i+1}",
                "timestamp": time.time()
            }
            # Messages are typically sent as bytes, so we'll encode our JSON string.
            message_body = json.dumps(task_data).encode('utf-8')

            channel.basic_publish(
                exchange='',          # In PTP, we often publish directly to a default exchange
                                      # that implicitly routes to the queue named by routing_key.
                routing_key=queue_name, # The routing key is the queue name for PTP
                body=message_body     # The message content, encoded as bytes
            )
            print(f"Producer application sent: {task_data}")
            time.sleep(1) # Simulate some work or delay between sending messages

    except Exception as e:
        print(f"An error occurred: {e}")
    finally:
        # 5. Ensure the connection is closed even if errors occur.
        if 'connection' in locals() and connection:
            connection.close()
        print("Producer application finished its run.")

if __name__ == "__main__":
    main()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_step_3_understand_the_producer_code"><a class="anchor" href="#_step_3_understand_the_producer_code"></a>Step 3: Understand the Producer Code</h3>
<div class="paragraph">
<p>Let&#8217;s break down the key parts of the <code>producer.py</code> script to understand its functionality:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><code>MessageBrokerClient</code> (Placeholder)</strong>: This class is a conceptual simulation. In a real application, you would replace it entirely with an actual client library for your chosen broker (e.g., <code>pika.BlockingConnection</code> for RabbitMQ, or <code>KafkaProducer</code> from <code>kafka-python</code>). Its methods (<code>connect</code>, <code>queue_declare</code>, <code>basic_publish</code>) mimic the common operations of such libraries.</p>
</li>
<li>
<p><strong><code>queue_name = 'task_queue'</code></strong>: This line defines the name of the queue where our messages will be sent. In a PTP model, both the producer and consumer must agree on this specific queue name to communicate.</p>
</li>
<li>
<p><strong><code>connection = MessageBrokerClient(&#8230;&#8203;)</code></strong>: This step establishes a connection to the message broker. This is the foundational first step for any messaging application that needs to interact with the broker.</p>
</li>
<li>
<p><strong><code>channel = connection.channel</code></strong>: Many messaging protocols (like AMQP, used by RabbitMQ) use the concept of "channels" within a single connection. A channel provides a lightweight, logical pathway for multiple operations to be multiplexed efficiently over a single underlying TCP connection.</p>
</li>
<li>
<p><strong><code>channel.queue_declare(queue_name=queue_name, durable=True)</code></strong>: This is a crucial step. It ensures that the <code>task_queue</code> exists on the message broker. If it doesn&#8217;t, the broker creates it. If it does, the operation does nothing, making it <strong>idempotent</strong>. The <code>durable=True</code> flag is important for reliability, as it tells the broker to persist the queue configuration across broker restarts.</p>
</li>
<li>
<p><strong><code>channel.basic_publish(&#8230;&#8203;)</code></strong>: This is the core function call for sending a message.</p>
</li>
<li>
<p><code>exchange=''</code>: In many PTP scenarios, messages are published to a <strong>default exchange</strong> which implicitly routes messages directly to the queue specified by the <code>routing_key</code>. This is a common pattern for simple PTP.</p>
</li>
<li>
<p><code>routing_key=queue_name</code>: For PTP, the <code>routing_key</code> is precisely the name of the destination queue. The broker uses this key to know where to deliver the message.</p>
</li>
<li>
<p><code>body=message_body</code>: The actual content of the message. It&#8217;s critical to encode the string into bytes (e.g., <code>json.dumps(&#8230;&#8203;).encode('utf-8')</code>) before sending, as messaging systems typically handle binary data for payloads.</p>
</li>
<li>
<p><strong><code>connection.close()</code></strong>: It&#8217;s good practice to gracefully close the connection to the message broker once all messages have been sent or when the application is shutting down. This releases resources on both the client and broker side.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_step_4_run_the_producer_application"><a class="anchor" href="#_step_4_run_the_producer_application"></a>Step 4: Run the Producer Application</h3>
<div class="paragraph">
<p>Execute the producer script from your terminal. Ensure your simulated (or actual) message broker is running and accessible at <code>localhost:5672</code> (or whatever address you&#8217;ve configured).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">python producer.py</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should observe output similar to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Connecting to message broker at localhost:5672...
Connection established.
Creating channel for communication...
Declared queue: 'task_queue' (durable: True)
Producer application sent: {'id': 1, 'description': 'Process data chunk 1', 'timestamp': 1678886400.12345}
 [x] Sent '{"id": 1, "description": "Process data chunk 1", "timestamp": 1678886400.12345}' to queue 'task_queue'
Producer application sent: {'id': 2, 'description': 'Process data chunk 2', 'timestamp': 1678886401.56789}
 [x] Sent '{"id": 2, "description": "Process data chunk 2", "timestamp": 1678886401.56789}' to queue 'task_queue'
Producer application sent: {'id': 3, 'description': 'Process data chunk 3', 'timestamp': 1678886402.90123}
 [x] Sent '{"id": 3, "description": "Process data chunk 3", "timestamp": 1678886402.90123}' to queue 'task_queue'
Producer application sent: {'id': 4, 'description': 'Process data chunk 4', 'timestamp': 1678886404.34567}
 [x] Sent '{"id": 4, "description": "Process data chunk 4", "timestamp": 1678886404.34567}' to queue 'task_queue'
Producer application sent: {'id': 5, 'description': 'Process data chunk 5', 'timestamp': 1678886405.78901}
 [x] Sent '{"id": 5, "description": "Process data chunk 5", "timestamp": 1678886405.78901}' to queue 'task_queue'
Connection gracefully closed.
Producer application finished its run.</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Note</strong>: The <code>[x] Sent &#8230;&#8203;</code> line is generated by our placeholder <code>MessageBrokerClient</code> to simulate the broker&#8217;s acknowledgment or internal logging. The <code>Producer application sent: &#8230;&#8203;</code> line is from our direct application logic, confirming what it attempted to send. The exact timestamps will vary with each run.</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_happens_next"><a class="anchor" href="#_what_happens_next"></a>What Happens Next?</h3>
<div class="paragraph">
<p>At this point, your producer application has successfully sent five messages to the <code>task_queue</code> on the message broker. These messages are now waiting in the queue for a consumer to retrieve them. Since no consumer is running yet, the messages will remain in the queue, demonstrating the asynchronous and decoupled nature of Message Oriented Middleware (MOM). In the next lab activity, you will develop a consumer application to retrieve and process these pending messages.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
