<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Implementing a subscriber for Publish/Subscribe :: ActiveMQ Artemis Clustering for High-Performance Messaging</title>
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">ActiveMQ Artemis Clustering for High-Performance Messaging</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/REPLACEREPONAME/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="amq-connection-distribution" data-version="1.0.0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">ActiveMQ Artemis Clustering for High-Performance Messaging</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../introduction-to-activemq-artemis/introduction-to-activemq-artemis.html">Introduction to ActiveMQ Artemis</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/understanding-message-oriented-middleware-mom.html">Understanding Message-Oriented Middleware (MOM)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/core-features-and-benefits-of-activemq-artemis.html">Core features and benefits of ActiveMQ Artemis</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/decoupling-producers-and-consumers.html">Decoupling Producers and Consumers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/asynchronous-communication-patterns.html">Asynchronous communication patterns</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduction-to-activemq-artemis/traffic-smoothing-and-competing-consumers.html">Traffic smoothing and competing consumers</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../client-side-challenges/client-side-challenges.html">Client-Side Challenges</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-challenges/bottlenecks-from-single-connection-to-a-single-broker.html">Bottlenecks from single connection to a single broker</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-challenges/impact-of-default-client-load-balancing-policies.html">Impact of default client load-balancing policies</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-challenges/reduced-cluster-throughput-due-to-message-redistribution.html">Reduced cluster throughput due to message redistribution</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client-side-challenges/risk-of-high-volume-queues-paging-messages-to-disk.html">Risk of high-volume queues paging messages to disk</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../deploying-amq-on-openshift/deploying-amq-on-openshift.html">Deploying AMQ on OpenShift</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/overview-of-red-hat-amq-operator.html">Overview of Red Hat AMQ Operator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/installing-the-amq-operator-on-openshift.html">Installing the AMQ Operator on OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/creating-an-activemqartemis-custom-resource-cr.html">Creating an ActiveMQArtemis Custom Resource (CR)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/configuring-a-two-node-activemq-artemis-cluster.html">Configuring a two-node ActiveMQ Artemis cluster</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../deploying-amq-on-openshift/exposing-broker-services-for-client-connections.html">Exposing broker services for client connections</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../solutions-for-even-message-distribution/solutions-for-even-message-distribution.html">Solutions for Even Message Distribution</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions-for-even-message-distribution/strategies-for-client-side-load-balancing.html">Strategies for client-side load balancing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions-for-even-message-distribution/configuring-client-connection-factories-for-multiple-brokers.html">Configuring client connection factories for multiple brokers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions-for-even-message-distribution/techniques-to-distribute-messages-evenly-across-cluster-members.html">Techniques to distribute messages evenly across cluster members</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../solutions-for-even-message-distribution/optimizing-client-connectivity-for-high-throughput.html">Optimizing client connectivity for high throughput</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster.html">Hands-on Lab: Deploying and Interacting with an ActiveMQ Artemis Cluster</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/setting-up-the-openshift-environment-for-amq-deployment.html">Setting up the OpenShift environment for AMQ deployment</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/deploying-a-two-node-activemq-artemis-cluster-using-the-operator.html">Deploying a two-node ActiveMQ Artemis cluster using the Operator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/developing-and-deploying-client-applications.html">Developing and deploying client applications</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/observing-message-distribution-and-cluster-behavior.html">Observing message distribution and cluster behavior</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hands-on-lab-deploying-and-interacting-with-an-activemq-artemis-cluster/testing-failover-scenarios-and-ha-capabilities.html">Testing failover scenarios and HA capabilities</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">ActiveMQ Artemis Clustering for High-Performance Messaging</span>
    <span class="version">1.0.0</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">ActiveMQ Artemis Clustering for High-Performance Messaging</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1.0.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">ActiveMQ Artemis Clustering for High-Performance Messaging</a></li>
    <li><a href="implementing-a-subscriber-for-publishsubscribe.html">Implementing a subscriber for Publish/Subscribe</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Implementing a subscriber for Publish/Subscribe</h1>
<h1 id="_implementing_a_subscriber_for_publishsubscribe" class="sect0"><a class="anchor" href="#_implementing_a_subscriber_for_publishsubscribe"></a>Implementing a Subscriber for Publish/Subscribe</h1>
<div class="paragraph">
<p>This section will guide you through the process of implementing a subscriber for the Publish/Subscribe (Pub/Sub) messaging model. A subscriber&#8217;s primary role is to express interest in specific message topics and consume messages published to those topics. This is a crucial component in achieving highly decoupled and scalable distributed systems, enabling multiple consumers to receive the same message from a single publisher.</p>
</div>
<div class="sect1">
<h2 id="_understanding_the_publishsubscribe_subscriber"><a class="anchor" href="#_understanding_the_publishsubscribe_subscriber"></a>Understanding the Publish/Subscribe Subscriber</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>In the Pub/Sub model, a <strong>subscriber</strong> is a component that registers its interest in one or more <strong>topics</strong> with a message broker. When a <strong>publisher</strong> sends a message to a particular topic, the broker ensures that all active subscribers to that topic receive a copy of the message. This mechanism allows for a "fan-out" pattern, where one message can be delivered to many interested parties simultaneously.</p>
</div>
<div class="paragraph">
<p>Unlike the Point-to-Point (PTP) model where each message is delivered to only one consumer, Pub/Sub allows for multiple consumers to process the same message, making it ideal for scenarios like broadcasting events, real-time data streaming, logging, or notification services.</p>
</div>
<div class="paragraph">
<p>Key characteristics of a Pub/Sub subscriber:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Topic-based interest</strong>: Subscribers don&#8217;t care who sent the message, only what topic it belongs to.</p>
</li>
<li>
<p><strong>Asynchronous consumption</strong>: Subscribers typically listen continuously for new messages without blocking the publisher.</p>
</li>
<li>
<p><strong>Decoupling</strong>: Publishers and subscribers have no direct knowledge of each other, communicating solely through the broker and topics.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The message broker plays a vital role here by managing subscriptions and routing messages efficiently to all relevant subscribers.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hands_on_lab_implementing_a_subscriber_for_publishsubscribe"><a class="anchor" href="#_hands_on_lab_implementing_a_subscriber_for_publishsubscribe"></a>Hands-on Lab: Implementing a Subscriber for Publish/Subscribe</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this lab, you will develop a Python-based subscriber application. This application will connect to our message broker, subscribe to a specific topic, and then continuously listen for and process messages published to that topic.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This lab assumes you have successfully completed the "Setting up a basic message broker" and "Implementing a publisher for Publish/Subscribe" labs, and that your message broker is running and accessible. We&#8217;ll use a generic <code>message_broker_client</code> concept for clarity, which can be adapted to specific broker technologies like RabbitMQ (using <code>pika</code>), Kafka (using <code>confluent-kafka-python</code>), or Redis Pub/Sub.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_prerequisites"><a class="anchor" href="#_prerequisites"></a>Prerequisites</h3>
<div class="paragraph">
<p>Before you begin, ensure you have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A running message broker (e.g., RabbitMQ, Kafka, Redis).</p>
</li>
<li>
<p>Python 3.x installed on your system.</p>
</li>
<li>
<p>The necessary client library for your chosen broker installed (e.g., <code>pip install pika</code> for RabbitMQ). For this example, we&#8217;ll simulate a generic client.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_step_1_create_the_subscriber_script"><a class="anchor" href="#_step_1_create_the_subscriber_script"></a>Step 1: Create the Subscriber Script</h3>
<div class="paragraph">
<p>Let&#8217;s create a new Python file named <code>subscriber.py</code>. This file will contain the logic for our subscriber.</p>
</div>
<div class="paragraph">
<p>Create the file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">touch subscriber.py</code></pre>
</div>
</div>
<div class="paragraph">
<p>Open <code>subscriber.py</code> in your favorite text editor.</p>
</div>
</div>
<div class="sect2">
<h3 id="_step_2_define_the_message_processing_logic"><a class="anchor" href="#_step_2_define_the_message_processing_logic"></a>Step 2: Define the Message Processing Logic</h3>
<div class="paragraph">
<p>The core of any subscriber is the function that gets called when a new message arrives. This function, often called a <code>callback</code> or <code>message_handler</code>, is where you&#8217;ll implement the business logic to process the received message.</p>
</div>
<div class="paragraph">
<p>Add the following code to <code>subscriber.py</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">import time
import json
# For a real application, replace this with your actual message broker client library
# For example, for RabbitMQ: import pika
# For Kafka: from confluent_kafka import Consumer, KafkaException

# --- Generic/Simulated Message Broker Client (for demonstration) ---
# In a real scenario, you would use a library like pika, confluent_kafka, etc.
class GenericMessageBrokerClient:
    def __init__(self, host='localhost', port=5672, client_id=""):
        self.host = host
        self.port = port
        self.client_id = client_id
        self.connection = None
        self.channel = None
        print(f"[{self.client_id}] Initializing generic broker client for {host}:{port}")

    def connect(self):
        # Simulate connection
        print(f"[{self.client_id}] Connecting to broker at {self.host}:{self.port}...")
        time.sleep(1) # Simulate network delay
        self.connection = True # Placeholder for actual connection object
        self.channel = True # Placeholder for actual channel object
        print(f"[{self.client_id}] Connection established.")
        return True

    def subscribe(self, topic_name, callback_function):
        if not self.connection:
            print(f"[{self.client_id}] Error: Not connected to broker.")
            return False
        print(f"[{self.client_id}] Subscribing to topic: '{topic_name}'...")
        # In a real client, this would set up the actual subscription.
        # For simulation, we'll store the callback and topic.
        self._callback = callback_function
        self._topic = topic_name
        print(f"[{self.client_id}] Successfully subscribed to '{topic_name}'.")
        return True

    def start_consuming(self):
        if not self.connection:
            print(f"[{self.client_id}] Error: Not connected to broker.")
            return

        print(f"[{self.client_id}] Waiting for messages on topic '{self._topic}'. To exit press CTRL+C")
        try:
            # Simulate continuous listening
            while True:
                # In a real broker client, this loop would block or poll for messages
                # and then invoke the callback.
                time.sleep(1) # Simulate polling interval
        except KeyboardInterrupt:
            print(f"[{self.client_id}] Disconnecting...")
        finally:
            self.disconnect()

    def disconnect(self):
        if self.connection:
            print(f"[{self.client_id}] Disconnecting from broker...")
            # Simulate disconnection
            self.connection = None
            self.channel = None
            print(f"[{self.client_id}] Disconnected.")

# -------------------------------------------------------------------

def message_callback(message_body):
    """
    This function will be called whenever a message is received.
    It takes the raw message body as input.
    """
    try:
        # Assuming messages are JSON encoded
        message_data = json.loads(message_body)
        print(f" [x] Received event: {message_data.get('event_type')}")
        print(f"     Payload: {message_data.get('payload')}")
        # Simulate some processing time
        time.sleep(0.5)
        print(" [x] Message processed.")
    except json.JSONDecodeError:
        print(f" [x] Received non-JSON message: {message_body}")
    except Exception as e:
        print(f" [!] Error processing message: {e}")

if __name__ == "__main__":
    # Configure your subscriber
    BROKER_HOST = 'localhost'
    BROKER_PORT = 5672 # Default for RabbitMQ
    TOPIC_NAME = 'sensor.data' # The topic we want to subscribe to

    # Create a subscriber instance
    subscriber = GenericMessageBrokerClient(BROKER_HOST, BROKER_PORT, client_id="DataSubscriber1")

    # 1. Connect to the message broker
    if not subscriber.connect():
        print("Failed to connect to the broker. Exiting.")
        exit(1)

    # 2. Subscribe to the desired topic
    # Note: In real clients, you might pass a specific queue name or allow the client to create one.
    # The crucial part is binding this queue to the 'sensor.data' topic/exchange.
    if not subscriber.subscribe(TOPIC_NAME, message_callback):
        print(f"Failed to subscribe to topic '{TOPIC_NAME}'. Exiting.")
        subscriber.disconnect()
        exit(1)

    # 3. Start consuming messages
    print(f"Waiting for messages on topic '{TOPIC_NAME}'. To exit press CTRL+C")
    subscriber.start_consuming()

    print("Subscriber application exited.")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_step_3_understand_the_code"><a class="anchor" href="#_step_3_understand_the_code"></a>Step 3: Understand the Code</h3>
<div class="paragraph">
<p>Let&#8217;s break down the key parts of the subscriber code:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><code>GenericMessageBrokerClient</code> (Simulated):</strong> This class is a stand-in for a real message broker client library (like <code>pika</code> for RabbitMQ). It encapsulates connection, subscription, and message consumption logic. In a production environment, you would replace this with the appropriate library for your broker.</p>
</li>
<li>
<p><strong><code>message_callback(message_body)</code> function:</strong></p>
</li>
<li>
<p>This is the heart of our subscriber. It&#8217;s designed to be executed every time the subscriber receives a message from the subscribed topic.</p>
</li>
<li>
<p>It expects the <code>message_body</code> to be a string, which we then attempt to parse as JSON. This is a common practice for structured data.</p>
</li>
<li>
<p>Inside this function, you would place your application-specific logic to process the data (e.g., store it in a database, trigger another service, update a dashboard).</p>
</li>
<li>
<p><strong><code>if <em>name</em> == "<em>main</em>":</code> block:</strong></p>
</li>
<li>
<p>This is the entry point of our script.</p>
</li>
<li>
<p>It defines the <code>BROKER_HOST</code>, <code>BROKER_PORT</code>, and <code>TOPIC_NAME</code> â€“ essential configuration details.</p>
</li>
<li>
<p>It initializes <code>GenericMessageBrokerClient</code>.</p>
</li>
<li>
<p><strong><code>subscriber.connect()</code>:</strong> Establishes a connection to the message broker. Without a connection, no messages can be sent or received.</p>
</li>
<li>
<p><strong><code>subscriber.subscribe(TOPIC_NAME, message_callback)</code>:</strong> This is where the subscriber registers its interest. It tells the broker: "I want to receive all messages sent to <code>TOPIC_NAME</code>, and when I get one, please call my <code>message_callback</code> function."</p>
</li>
<li>
<p><strong><code>subscriber.start_consuming()</code>:</strong> This method enters a loop that continuously listens for incoming messages. It will keep the subscriber application running until explicitly stopped (e.g., by pressing <code>Ctrl+C</code>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_step_4_run_the_subscriber"><a class="anchor" href="#_step_4_run_the_subscriber"></a>Step 4: Run the Subscriber</h3>
<div class="paragraph">
<p>Open a terminal and navigate to the directory where you saved <code>subscriber.py</code>.</p>
</div>
<div class="paragraph">
<p>Execute the subscriber script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">python subscriber.py</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should see output similar to this, indicating the subscriber is connected and waiting for messages:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">[DataSubscriber1] Initializing generic broker client for localhost:5672
[DataSubscriber1] Connecting to broker at localhost:5672...
[DataSubscriber1] Connection established.
[DataSubscriber1] Subscribing to topic: 'sensor.data'...
[DataSubscriber1] Successfully subscribed to 'sensor.data'.
Waiting for messages on topic 'sensor.data'. To exit press CTRL+C
[DataSubscriber1] Waiting for messages on topic 'sensor.data'. To exit press CTRL+C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Leave this terminal window open.</p>
</div>
</div>
<div class="sect2">
<h3 id="_step_5_test_with_a_publisher"><a class="anchor" href="#_step_5_test_with_a_publisher"></a>Step 5: Test with a Publisher</h3>
<div class="paragraph">
<p>Now, open a <strong>second</strong> terminal window. In this terminal, run your publisher application (from the "Implementing a publisher for Publish/Subscribe" lab) which sends messages to the <code>sensor.data</code> topic.</p>
</div>
<div class="paragraph">
<p>Execute the publisher script (assuming it&#8217;s named <code>publisher.py</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">python publisher.py</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should see the publisher sending messages:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">[EventPublisher] Initializing generic broker client for localhost:5672
[EventPublisher] Connecting to broker at localhost:5672...
[EventPublisher] Connection established.
[EventPublisher] Declaring topic 'sensor.data'...
[EventPublisher] Topic 'sensor.data' ready.
[EventPublisher] Publishing message to 'sensor.data': {"event_type": "temperature_reading", "payload": {"device_id": "sensor-123", "temperature_c": 22.5, "timestamp": "2023-10-27T10:00:00Z"}}
[EventPublisher] Publishing message to 'sensor.data': {"event_type": "humidity_reading", "payload": {"device_id": "sensor-124", "humidity_percent": 65.2, "timestamp": "2023-10-27T10:00:01Z"}}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Simultaneously, observe the output in your <strong>first</strong> terminal window (where the subscriber is running). You should see the subscriber receiving and processing each message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">[DataSubscriber1] Waiting for messages on topic 'sensor.data'. To exit press CTRL+C
 [x] Received event: temperature_reading
     Payload: {'device_id': 'sensor-123', 'temperature_c': 22.5, 'timestamp': '2023-10-27T10:00:00Z'}
 [x] Message processed.
 [x] Received event: humidity_reading
     Payload: {'device_id': 'sensor-124', 'humidity_percent': 65.2, 'timestamp': '2023-10-27T10:00:01Z'}
 [x] Message processed.</code></pre>
</div>
</div>
<div class="paragraph">
<p>This confirms that your subscriber is successfully connecting to the broker, subscribing to the specified topic, and receiving messages published to that topic.</p>
</div>
</div>
<div class="sect2">
<h3 id="_step_6_test_with_multiple_subscribers_optional"><a class="anchor" href="#_step_6_test_with_multiple_subscribers_optional"></a>Step 6: Test with Multiple Subscribers (Optional)</h3>
<div class="paragraph">
<p>To fully appreciate the fan-out capability of Pub/Sub, you can run multiple instances of the <code>subscriber.py</code> script.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open a <strong>third</strong> terminal window.</p>
</li>
<li>
<p>Run the subscriber script again in this new terminal:
[source,bash]
----
python subscriber.py
----
You will have two subscribers running concurrently.</p>
</li>
<li>
<p>Go back to your publisher terminal and run the publisher script again.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Observe both subscriber terminals. You will see <strong>both</strong> subscribers receiving and processing <strong>every</strong> message published by the publisher. This demonstrates how Pub/Sub enables one-to-many communication efficiently.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you are using a real broker like RabbitMQ, each subscriber will typically create its own exclusive queue that is bound to the exchange (topic). This ensures that each subscriber gets its own copy of all messages published to that exchange.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_troubleshooting_tips"><a class="anchor" href="#_troubleshooting_tips"></a>Troubleshooting Tips</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Broker not running</strong>: Ensure your message broker service is active and accessible. Check its logs for errors.</p>
</li>
<li>
<p><strong>Connection Refused</strong>: This usually means the subscriber cannot reach the broker. Verify the <code>BROKER_HOST</code> and <code>BROKER_PORT</code> are correct, and that no firewall is blocking the connection.</p>
</li>
<li>
<p><strong>Messages not received</strong>:</p>
</li>
<li>
<p>Double-check that the <code>TOPIC_NAME</code> in your publisher and subscriber match exactly.</p>
</li>
<li>
<p>Ensure the publisher is actually sending messages.</p>
</li>
<li>
<p>Verify the broker&#8217;s management interface (if available) to see if messages are flowing to the topic/exchange.</p>
</li>
<li>
<p><strong>Library specific issues</strong>: If using a real library like <code>pika</code> or <code>confluent-kafka-python</code>, refer to their documentation for specific connection and subscription parameters, especially for error handling and retries.</p>
</li>
<li>
<p><strong>Callback errors</strong>: If your <code>message_callback</code> function has an error, it might stop processing subsequent messages depending on the broker client library. Implement robust error handling within your callback.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You have now successfully implemented a subscriber for the Publish/Subscribe messaging model, demonstrating its ability to consume messages from a specific topic and enable one-to-many communication in a distributed system.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
