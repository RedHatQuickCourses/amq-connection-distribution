#  Implementing message producers in Spring Boot

= Implementing Message Producers in Spring Boot

Spring Boot provides robust integration with Java Message Service (JMS) brokers like ActiveMQ Artemis, simplifying the development of message-driven applications. Implementing a message producer involves configuring the connection to the broker and using Spring's `JmsTemplate` to send messages to a specified destination (queue or topic).

=== Understanding Message Producers in Spring Boot

A message producer in a messaging system is responsible for creating and sending messages to a destination, from where they can be consumed by other applications. In Spring Boot, the `JmsTemplate` class is the central component for synchronous JMS operations, abstracting away the complexities of the JMS API.

When implementing a message producer with ActiveMQ Artemis in Spring Boot, you'll typically:

.  Configure the connection properties for ActiveMQ Artemis.
.  Inject `JmsTemplate` into your service or component.
.  Use methods provided by `JmsTemplate` to send messages to a queue or topic.

=== Key Components for Message Production

==== JmsTemplate

`JmsTemplate` handles the creation and release of JMS resources (connections, sessions, producers). It provides a variety of `send` and `convertAndSend` methods to accommodate different messaging scenarios.

*   `send(String destinationName, MessageCreator messageCreator)`: Allows you to create the JMS `Message` object manually using a `MessageCreator` callback. This provides fine-grained control over message properties and headers.
*   `convertAndSend(String destinationName, Object message)`: This is the most common and convenient method. It takes a Java object, converts it into a JMS `Message` (e.g., a `TextMessage` for `String`, `ObjectMessage` for serializable objects), and sends it to the specified destination.
*   `convertAndSend(Destination destination, Object message)`: Similar to the above, but takes a `javax.jms.Destination` object directly.

==== Destinations (Queues and Topics)

Messages are sent to destinations, which can be either *queues* or *topics*:

*   *Queues (Point-to-Point)*: Messages are delivered to only one consumer among potentially many. Ideal for task distribution and workload balancing.
*   *Topics (Publish/Subscribe)*: Messages are broadcast to all active subscribers. Ideal for event notification and broadcasting information.

You specify the destination name (e.g., "myQueue", "myTopic") when using `JmsTemplate`. Spring Boot's auto-configuration will recognize these names and interact with Artemis appropriately.

=== Hands-on Activity: Developing a Simple Spring Boot Message Producer

Let's create a Spring Boot application that acts as a message producer, sending simple text messages to an ActiveMQ Artemis queue.

==== Prerequisites

*   A running ActiveMQ Artemis instance or cluster (e.g., deployed on OpenShift as per previous labs).
*   Maven or Gradle installed.
*   Java Development Kit (JDK) 11 or newer.
*   An IDE like IntelliJ IDEA or VS Code.

==== Step 1: Create a Spring Boot Project

Generate a new Spring Boot project using Spring Initializr (https://start.spring.io/) with the following dependencies:

*   `Spring Web` (optional, for a REST endpoint to trigger message sending)
*   `Spring for Apache ActiveMQ 5` (this is the Spring Boot starter for JMS)

Alternatively, add these to your `pom.xml`:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.5</version> <!-- Use a recent Spring Boot version -->
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.example</groupId>
    <artifactId>artemis-producer</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>artemis-producer</name>
    <description>Demo project for ActiveMQ Artemis Producer</description>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-activemq</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
----

==== Step 2: Configure ActiveMQ Artemis Connection

Open `src/main/resources/application.properties` (or `application.yml`) and add the connection details for your ActiveMQ Artemis instance.

[source,properties]
----
# ActiveMQ Artemis Broker Configuration
spring.activemq.broker-url=tcp://localhost:61616  // <1>
spring.activemq.user=admin                          // <2>
spring.activemq.password=admin                      // <3>

# Enable JMS transactional support if needed (false by default)
# spring.jms.pub-sub-domain=false // Set to true for topics, false for queues (default)
----
<1> Replace `localhost:61616` with the actual hostname/IP and port of your Artemis broker. If running on OpenShift, this would be the service URL (e.g., `amqp://artemis-broker-service.my-namespace.svc.cluster.local:61616`).
<2> Use the appropriate username for your Artemis broker.
<3> Use the appropriate password for your Artemis broker.

==== Step 3: Create the Message Producer Service

Create a Java class `JmsProducer.java` that will contain the logic for sending messages.

[source,java]
----
package com.example.artemisproducer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Service;

@Service // <1>
public class JmsProducer {

    private static final Logger log = LoggerFactory.getLogger(JmsProducer.class);

    private final JmsTemplate jmsTemplate; // <2>

    @Autowired // <3>
    public JmsProducer(JmsTemplate jmsTemplate) {
        this.jmsTemplate = jmsTemplate;
    }

    public void sendMessage(String destination, String message) {
        log.info("Sending message '{}' to destination '{}'", message, destination);
        jmsTemplate.convertAndSend(destination, message); // <4>
    }

    public void sendMessageWithCustomCreator(String destination, String messageBody, String customProperty) {
        log.info("Sending message with custom properties '{}' to destination '{}'", messageBody, destination);
        jmsTemplate.send(destination, session -> { // <5>
            javax.jms.TextMessage message = session.createTextMessage(messageBody);
            message.setStringProperty("customHeader", customProperty); // <6>
            return message;
        });
    }
}
----
<1> `@Service` marks this class as a Spring service component.
<2> `JmsTemplate` is injected. Spring Boot's auto-configuration will create and configure a `JmsTemplate` instance based on `application.properties`.
<3> Constructor injection is used for `JmsTemplate`.
<4> The `convertAndSend` method is used to send a simple `String` message. Spring converts it to a `TextMessage` automatically.
<5> The `send` method with a `MessageCreator` allows for more control, letting you define the `Message` object and its properties explicitly.
<6> Here, a custom header `customHeader` is added to the JMS message.

==== Step 4: Create a REST Controller to Trigger Message Sending (Optional but convenient for testing)

Create a Java class `MessageController.java` to expose a REST endpoint to send messages.

[source,java]
----
package com.example.artemisproducer;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController // <1>
public class MessageController {

    private final JmsProducer jmsProducer;

    @Autowired
    public MessageController(JmsProducer jmsProducer) {
        this.jmsProducer = jmsProducer;
    }

    @PostMapping("/send") // <2>
    public String send(@RequestParam String destination, @RequestParam String message) {
        jmsProducer.sendMessage(destination, message);
        return "Message sent successfully to " + destination;
    }

    @PostMapping("/send-custom") // <3>
    public String sendWithCustom(@RequestParam String destination, @RequestParam String message, @RequestParam String property) {
        jmsProducer.sendMessageWithCustomCreator(destination, message, property);
        return "Message with custom property sent successfully to " + destination;
    }
}
----
<1> `@RestController` combines `@Controller` and `@ResponseBody`, making it easy to create RESTful web services.
<2> A POST endpoint `/send` to send basic messages.
<3> A POST endpoint `/send-custom` to demonstrate sending messages with custom properties.

==== Step 5: Run the Application

Navigate to the root of your project in a terminal and run the Spring Boot application:

[source,bash]
----
./mvnw spring-boot:run
----

You should see logs indicating that the application has started and connected to ActiveMQ Artemis.

==== Step 6: Test the Producer

Use `curl` or a tool like Postman to send messages:

.  **Send a simple message**:
+
[source,bash]
----
curl -X POST "http://localhost:8080/send?destination=myQueue&message=HelloFromSpringBootProducer"
----
+
This will send "HelloFromSpringBootProducer" to a queue named `myQueue`.

.  **Send a message with a custom property**:
+
[source,bash]
----
curl -X POST "http://localhost:8080/send-custom?destination=myQueue&message=MessageWithProps&property=Value123"
----
+
This will send "MessageWithProps" to `myQueue` and include a JMS property `customHeader` with the value `Value123`.

You can verify these messages by checking the ActiveMQ Artemis web console or by having a consumer application subscribed to `myQueue`.

=== Expert-Level Insights and Troubleshooting

*   **Connection Pooling**: Spring Boot auto-configures a `CachingConnectionFactory` by default, which wraps the standard JMS `ConnectionFactory` to cache `Connection`, `Session`, and `MessageProducer` instances. This significantly improves performance by reducing the overhead of creating new JMS resources for each message.
*   **Transactions**: For reliable messaging, especially when combining JMS operations with database transactions, you can enable JTA (Java Transaction API) and use `@Transactional` annotations. Spring will automatically enlist the JMS operations in the current transaction.
+
[source,java]
----
// In your producer service
import jakarta.transaction.Transactional; // or org.springframework.transaction.annotation.Transactional

@Service
public class JmsTransactionalProducer {

    @Autowired
    private JmsTemplate jmsTemplate;

    @Transactional
    public void sendTransactionalMessage(String destination, String messageContent) {
        // Perform some database operation (e.g., save to DB)
        // ...
        jmsTemplate.convertAndSend(destination, messageContent);
        // If an exception occurs here or in the DB operation,
        // both the DB transaction and the JMS message send will be rolled back.
    }
}
----
*   **Error Handling**: `JmsTemplate` methods can throw `JmsException` (a runtime exception) if an issue occurs during message sending. It's good practice to wrap `JmsTemplate` calls in `try-catch` blocks for specific error handling, logging, or retry mechanisms.
*   **Custom Message Converters**: For sending complex Java objects, you might need to configure a custom `MessageConverter`. By default, `JmsTemplate` uses `SimpleMessageConverter` which handles `String`, `Map`, `byte[]`, and `Serializable` objects. For example, to send JSON payloads, you could use `MappingJackson2MessageConverter`.
+
[source,java]
----
// Example: Configuring a custom MessageConverter for JSON
@Configuration
public class JmsConfig {

    @Bean
    public MessageConverter jacksonJmsMessageConverter() {
        MappingJackson2MessageConverter converter = new MappingJackson2MessageConverter();
        converter.setTargetType(MessageType.TEXT); // Send as TextMessage
        converter.setTypeIdPropertyName("_type"); // Add a type header for deserialization
        return converter;
    }
}
----
*   **Asynchronous Sending**: While `JmsTemplate` is synchronous, you can combine it with Spring's `@Async` annotation on your producer service methods to make the sending operation non-blocking for the caller. Ensure you have `@EnableAsync` on your main application class or a configuration class.
*   **Security**: For production environments, ensure that your ActiveMQ Artemis instance is secured with proper authentication and authorization. The `spring.activemq.user` and `spring.activemq.password` properties should use strong credentials, and ideally, retrieved from a secure secret management system rather than hardcoded.
*   **Payload Size**: Be mindful of the message payload size. Extremely large messages can impact performance and memory usage on both the broker and client sides. For very large data, consider storing the data in an external system (e.g., S3, database) and sending only a reference (e.g., an ID) through the message queue.