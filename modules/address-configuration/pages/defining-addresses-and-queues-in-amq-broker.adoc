#  Defining addresses and queues in AMQ Broker

:amq-broker-on-openshift-address-config:
image::amq-broker-on-openshift-address-config.png[AMQ Broker on OpenShift Address Configuration,width=800,float=right]

= Defining Addresses and Queues in AMQ Broker

This section delves into the fundamental concepts of addresses and queues within Red Hat AMQ Broker, essential for organizing and routing messages effectively. We will explore their roles, how they relate to different messaging patterns, and how to configure them in an OpenShift environment using the AMQ Broker Operator.

== Understanding Addresses

In the context of a message broker like Red Hat AMQ Broker, an *address* serves as a logical endpoint or destination to which producers send messages. It acts as a routing mechanism, determining where a message will ultimately be stored and subsequently consumed. Think of an address as a street name; messages are sent to this "street," and the broker then routes them to specific "houses" (queues) on that street based on defined rules.

Addresses are critical for abstracting the underlying physical storage (queues) from the producers. A producer only needs to know the address to send a message, not the specific queue(s) where it will be stored. This decouples producers from consumers, enhancing flexibility and scalability.

AMQ Broker supports two primary types of message routing associated with addresses:

=== Anycast Routing

*   *Concept:* Anycast routing implements a point-to-point messaging pattern, where a message sent to an address is delivered to *at most one* of the available queues bound to that address.
*   *Behavior:* When multiple consumers are subscribed to queues associated with an Anycast address, the broker ensures that each message is delivered to only one consumer. This is typically achieved through load-balancing mechanisms.
*   *Use Cases:* This pattern is ideal for task distribution, work queues, or scenarios where each message needs to be processed exactly once by a single worker.
*   *Example:* If an "order-processing" address uses Anycast routing and there are three order-processing queues (and thus three consumers), a new order message will be delivered to only one of those queues for processing.

=== Multicast Routing

*   *Concept:* Multicast routing implements a publish-subscribe (pub/sub) messaging pattern, where a message sent to an address is delivered to *all* available queues bound to that address.
*   *Behavior:* Every queue associated with a Multicast address receives a copy of the message. This means multiple consumers, each listening to a different queue, can independently process the same message.
*   *Use Cases:* This pattern is suitable for broadcasting information, event streaming, notifications, or any scenario where multiple interested parties need to receive the same message.
*   *Example:* An "weather-updates" address using Multicast routing would deliver a new weather update message to all queues (and their respective consumers) bound to it, ensuring every subscribed application receives the update.

image::amq-broker-routing.png[AMQ Broker Routing Types,width=800]
_Figure 1: Comparison of Anycast and Multicast Routing_

== Understanding Queues

A *queue* is a physical storage mechanism within the AMQ Broker that holds messages until they are consumed. While addresses define the conceptual destination, queues represent the actual storage locations from which consumers retrieve messages.

=== Relationship between Addresses and Queues

*   **Binding:** One or more queues can be bound to an address. This binding determines how messages sent to that address are routed to the queues.
*   **Routing Type Influence:**
    *   For an *Anycast* address, messages are routed to *one* of its bound queues.
    *   For a *Multicast* address, messages are routed to *all* of its bound queues.
*   **Consumer Endpoint:** Consumers subscribe to specific queues to receive messages. They don't typically subscribe directly to addresses.

=== Queue Characteristics

Queues can have various configurations that influence their behavior:

*   **Durability:**
    *   *Durable Queues:* Messages stored in durable queues persist across broker restarts. This is crucial for applications that require guaranteed message delivery even if the broker goes offline.
    *   *Non-Durable Queues (Temporary Queues):* Messages in non-durable queues are lost if the broker restarts. These are often used for temporary communication or non-critical data.
*   **Max Consumers:** Defines the maximum number of consumers allowed to connect to a queue simultaneously.
*   **Purge On No Consumers:** Automatically purges messages from the queue if there are no active consumers.
*   **Auto-create/Auto-delete:** Queues can be configured to be automatically created when a producer sends a message to their associated address or when a consumer tries to connect, and automatically deleted when they become empty and have no consumers. While convenient for dynamic environments, explicit configuration via Custom Resources provides better control and predictability in production.

== How AMQ Broker Manages Addresses and Queues on OpenShift

When deploying AMQ Broker on OpenShift using the AMQ Broker Operator, the configuration of addresses and queues is primarily managed through the broker's Custom Resource (CR). The Operator watches for changes in this CR and reconciles the broker instance to match the desired state.

By default, AMQ Broker can auto-create addresses and queues when producers send messages or consumers attempt to connect. However, for robust production deployments, it's best practice to explicitly define addresses and queues in the `ActiveMQArtemis` CR. This provides:

*   **Predictability:** Ensures that the required messaging infrastructure is always present and configured as expected.
*   **Control:** Allows for fine-grained configuration of routing types, queue properties, and other advanced settings.
*   **Idempotency:** The Operator ensures the desired state is maintained even if manual changes are made or the broker restarts.

The `addresses` section within the `spec` of the `ActiveMQArtemis` Custom Resource is where you define these components. Each address definition includes its name, routing type, and an array of `queue` definitions.

=== Example CR Structure for Addresses and Queues

```yaml
apiVersion: broker.amq.io/v1beta1
kind: ActiveMQArtemis
metadata:
  name: my-broker
spec:
  # ... other broker configurations ...
  addresses:
    - name: my.anycast.address # Name of the address
      routingType: anycast    # Set routing type to Anycast
      queueConfiguration:
        - name: my.anycast.queue # Queue bound to the Anycast address
          routingType: anycast
          durable: true        # Make the queue durable
          maxConsumers: 1      # Only allow one consumer at a time
          # autoCreateAddresses: true # Optional: enable or disable auto-creation
          # autoDeleteAddresses: true # Optional: enable or disable auto-deletion
    - name: my.multicast.address # Name of the address
      routingType: multicast   # Set routing type to Multicast
      queueConfiguration:
        - name: my.multicast.queue.1 # First queue for Multicast
          routingType: multicast
          durable: true
        - name: my.multicast.queue.2 # Second queue for Multicast
          routingType: multicast
          durable: true
  # ... more configurations ...
```

In this structure:
*   The `addresses` array defines one or more addresses.
*   Each `address` entry must have a `name` and `routingType` (either `anycast` or `multicast`).
*   The `queueConfiguration` array within an address defines the queues bound to that address. Each queue also has a `name`, `routingType` (matching the address's routing type for consistency), and other properties like `durable`.

== Hands-on Lab: Configuring Addresses and Queues

In this lab, you will deploy an AMQ Broker instance on OpenShift and configure custom addresses and queues using its Custom Resource (CR).

=== Prerequisites

*   Access to an OpenShift cluster.
*   `oc` CLI tool configured and logged into the cluster.
*   The Red Hat AMQ Broker Operator must be installed in your OpenShift cluster. (This would typically be covered in an earlier lab on Operator deployment).

=== Lab Steps

==== 1. Log in to OpenShift and Create a Project

Ensure you are logged in to your OpenShift cluster.

[source,bash,subs="attributes+"]
----
oc login --token=<YOUR_TOKEN> --server=<YOUR_OPENSHIFT_API_URL>
oc new-project amq-broker-addresses --display-name="AMQ Broker Addresses Lab"
----

==== 2. Deploy a Basic AMQ Broker Instance

Create a file named `broker-instance.yaml` with the following content. This will deploy a minimal AMQ Broker instance.

[source,yaml,subs="attributes+"]
----
apiVersion: broker.amq.io/v1beta1
kind: ActiveMQArtemis
metadata:
  name: my-amq-broker
spec:
  deploymentPlan:
    size: 1
    image: registry.redhat.io/amq7/amq-broker-rhel8:latest # Use a specific image version for stability
    extraMounts:
      - name: data
        pvc: broker-data
  brokerProperties:
    - 'haPolicy.enabled=false' # Disable HA for a simple lab setup
    - 'securitySettings.#.fullMessageReads=true' # Allow full message reads for admin
    - 'securitySettings.#.send=true'
    - 'securitySettings.#.receive=true'
    - 'securitySettings.#.createDurableQueue=true'
    - 'securitySettings.#.deleteDurableQueue=true'
    - 'securitySettings.#.createNonDurableQueue=true'
    - 'securitySettings.#.deleteNonDurableQueue=true'
  console:
    expose: true # Expose the Hawtio console for inspection (optional, but useful)
  journalStorage:
    size: 1Gi
  webPorts:
    - name: https
      port: 8161
      tls: true
  acceptors:
    - name: amqp
      protocols: amqp
      port: 5672
      sslEnabled: false
  users:
    - username: admin
      password: admin
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: broker-data
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
  storageClassName: gp2 # Use an appropriate StorageClass for your OpenShift cluster
----

Apply the YAML to deploy the broker:

[source,bash,subs="attributes+"]
----
oc apply -f broker-instance.yaml
----

Wait for the broker pod to be running. You can check its status:

[source,bash,subs="attributes+"]
----
oc get activemqartemises my-amq-broker -o jsonpath='{.status.brokerStatus[0].state}'
oc get pods -l app.kubernetes.io/name=activemqartemis-broker
----

Once the pod is running and the `ActiveMQArtemis` status shows `Running`, proceed to the next step.

==== 3. Configure Addresses and Queues in the Broker CR

Now, you will modify the `ActiveMQArtemis` CR to define our custom addresses and queues.

Edit the `my-amq-broker` instance:

[source,bash,subs="attributes+"]
----
oc edit activemqartemises my-amq-broker
----

Locate the `spec:` section and add the `addresses:` block as shown below. Make sure to indent it correctly under `spec:`.

[source,yaml]
----
# ... (existing content) ...
spec:
  # ... (existing content like deploymentPlan, brokerProperties, etc.) ...
  addresses:
    - name: my.anycast.orders
      routingType: anycast
      queueConfiguration:
        - name: order.queue.processor-1
          routingType: anycast
          durable: true
          maxConsumers: 1
          # Optionally configure auto-creation/deletion if needed, but explicit is clearer
          # autoCreateQueues: false
          # autoDeleteQueues: false
        - name: order.queue.processor-2
          routingType: anycast
          durable: true
          maxConsumers: 1
    - name: my.multicast.events
      routingType: multicast
      queueConfiguration:
        - name: event.queue.logger
          routingType: multicast
          durable: true
        - name: event.queue.notifier
          routingType: multicast
          durable: true
        - name: event.queue.archive
          routingType: multicast
          durable: true
  # ... (rest of the existing content) ...
----

Save and exit the editor. The AMQ Broker Operator will detect the change and reconfigure the broker. This might cause the broker pod to restart, which is expected behavior for certain CR modifications.

==== 4. Verify the Configuration

You can verify the created addresses and queues by accessing the AMQ Broker management console (Hawtio).

1.  Get the route for the Hawtio console:
    [source,bash,subs="attributes+"]
    ----
    oc get route my-amq-broker-console -o jsonpath='{.spec.host}'
    ----
    This will output the URL, e.g., `my-amq-broker-console-amq-broker-addresses.apps.cluster.example.com`.
2.  Open this URL in your web browser.
3.  Log in with username `admin` and password `admin`.
4.  Navigate to the "Runtime" tab, then find your broker instance (e.g., `amq-broker-0`).
5.  Expand "Addresses" and "Queues" in the tree view on the left.
6.  You should see the `my.anycast.orders` and `my.multicast.events` addresses.
7.  Under `my.anycast.orders`, you should see `order.queue.processor-1` and `order.queue.processor-2` queues.
8.  Under `my.multicast.events`, you should see `event.queue.logger`, `event.queue.notifier`, and `event.queue.archive` queues.

This confirms that the addresses and queues were successfully configured via the Custom Resource.

==== 5. Cleanup

To remove the resources created in this lab, run:

[source,bash,subs="attributes+"]
----
oc delete -f broker-instance.yaml
oc delete project amq-broker-addresses
----

This lab demonstrated how to explicitly define and configure addresses and queues for your Red Hat AMQ Broker instance on OpenShift, providing a solid foundation for managing your messaging topology.