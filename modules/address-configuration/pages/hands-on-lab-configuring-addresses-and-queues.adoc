#  Hands-on Lab: Configuring Addresses and Queues

[#_lab_configuring_addresses_and_queues]
= Hands-on Lab: Configuring Addresses and Queues

This lab guides you through the process of defining and configuring addresses and queues for a Red Hat AMQ Broker instance deployed on OpenShift. You will learn how to use the AMQ Broker Operator's Custom Resources (CRs) to manage messaging destinations, including advanced settings like dead letter queues, expiry queues, and message grouping.

[NOTE]
This lab assumes you have already deployed an AMQ Broker instance named `amq-broker-sample` in your current OpenShift project using the AMQ Broker Operator. If not, please refer to the "Deploying AMQ Broker instances using the Operator" lab first.

== Objectives

Upon completion of this lab, you will be able to:

*   Define new addresses and queues within an existing AMQ Broker instance.
*   Apply various address settings, including message persistence, redelivery, and maximum message size.
*   Configure Dead Letter Queues (DLQs) and Expiry Queues for robust message handling.
*   Enable and configure message grouping capabilities on addresses.
*   Verify your configurations using `oc` commands and the Hawtio console.

== Prerequisites

*   Access to an OpenShift cluster.
*   The `oc` command-line tool installed and configured to access your cluster.
*   An `ActiveMQArtemis` instance named `amq-broker-sample` running in your current OpenShift project.
*   (Optional) Access to the Hawtio console for your AMQ Broker instance for visual verification.

== Step 1: Inspect the Current Broker Configuration

Before making changes, let's examine the current configuration of your AMQ Broker instance. This helps us understand its current state and where we'll be adding new address definitions.

.Procedure
.  Execute the following command to retrieve the YAML definition of your broker's `ActiveMQArtemis` custom resource:
+
.Command
```bash
oc get activemqartemis amq-broker-sample -o yaml
```

.Expected Output (Snippet)
You will see a detailed YAML output of your broker's `ActiveMQArtemis` custom resource. Look for the `spec` section. Initially, there might not be an `addresses` block, or it might be empty if no custom addresses were defined during deployment.

```yaml
# ... (truncated output) ...
spec:
  deploymentPlan:
    image: registry.redhat.io/amq7/amq-broker-rhel8:7.11
    size: 1
  # ... (other settings) ...
  # Look for an 'addresses:' section here.
# ... (truncated output) ...
```

== Step 2: Create a Basic Address and Queue

In AMQ Broker, an *address* is a conceptual endpoint that messages are sent to. A *queue* is a physical destination where messages are stored, and it's bound to one or more addresses. When you send a message to an address, the broker routes it to the bound queues based on the address's routing type.

We will add a simple address named `my-training-address` and bind a queue named `my-training-queue` to it. By default, queues will be created with `ANYCAST` routing, which means each message is delivered to only one consumer among all consumers attached to the queue. `MULTICAST` routing would deliver a copy of the message to all consumers on all queues bound to the address. We'll make the queue `durable` so messages persist even if the broker restarts.

.Procedure
.  Create a patch file named `add-address.yaml` with the following content:
+
.File: `add-address.yaml`
```yaml
spec:
  addresses:
    - name: my-training-address
      applyToBroker: true # Ensures the operator applies this configuration to the broker
      queues:
        - name: my-training-queue
          routingType: anycast # Explicitly set Anycast routing (default for queues)
          durable: true        # Make the queue durable so messages persist broker restarts
```
+
.  Apply the patch to your `amq-broker-sample` instance. The `type=merge` option allows you to add or update specific sections of the CR without overwriting the entire resource.
+
.Command
```bash
oc patch activemqartemis amq-broker-sample --type=merge --patch-file=add-address.yaml
```
+
.  Verify that the address and queue have been created by inspecting the broker's CR. We'll use `grep` to quickly find the relevant section:
+
.Command
```bash
oc get activemqartemis amq-broker-sample -o yaml | grep -A 7 "my-training-address"
```
+
.Expected Output (Snippet)
```yaml
    - name: my-training-address
      applyToBroker: true
      queues:
      - durable: true
        name: my-training-queue
        routingType: anycast
```
+
You can also verify this by logging into the Hawtio console for your AMQ Broker instance. Navigate to the *Runtime* tab, then *ActiveMQ Artemis* -> *Addresses* and *Queues*. You should see `my-training-address` and `my-training-queue` listed.

== Step 3: Configure Advanced Address Settings

Addresses and queues can be configured with various settings to control message behavior, resource consumption, and reliability. Let's update `my-training-address` to include some common settings:

*   `maxSizeBytes`: The maximum total size of messages allowed in the address's queues before blocking producers or dropping messages (if `address-full-policy` is set).
*   `redeliveryDelay`: The delay (in milliseconds) before a message that failed delivery (e.g., due to consumer acknowledgment failure) is redelivered.
*   `maxDeliveryAttempts`: The maximum number of times a message will be redelivered to a consumer before being moved to a Dead Letter Queue (if configured).

.Procedure
.  Create a patch file named `update-address-settings.yaml` with the following content. This patch specifically targets `my-training-address` using `match` in the `addressSettings` block.
+
.File: `update-address-settings.yaml`
```yaml
spec:
  addresses:
    - name: my-training-address # This refers to the address we created
      addressSettings:
        - match: my-training-address # Apply these settings to this specific address
          maxSizeBytes: 10485760     # 10 MB limit for the address's queues (10 * 1024 * 1024)
          redeliveryDelay: 5000      # 5 seconds redelivery delay
          maxDeliveryAttempts: 3     # Try to deliver 3 times before potential DLQ routing
```
+
.  Apply the patch to your `amq-broker-sample` instance:
+
.Command
```bash
oc patch activemqartemis amq-broker-sample --type=merge --patch-file=update-address-settings.yaml
```
+
.  Verify the updated settings by inspecting the broker's CR again:
+
.Command
```bash
oc get activemqartemis amq-broker-sample -o yaml | grep -A 5 "my-training-address"
```
+
.Expected Output (Snippet)
You should see the `addressSettings` block now correctly configured under `my-training-address`.
```yaml
    - name: my-training-address
      addressSettings:
      - match: my-training-address
        maxDeliveryAttempts: 3
        maxSizeBytes: 10485760
        redeliveryDelay: 5000
```

== Step 4: Configure a Dead Letter Queue (DLQ) and Expiry Queue

Dead Letter Queues (DLQs) are essential for handling messages that cannot be delivered successfully after a certain number of attempts (`maxDeliveryAttempts`) or that are rejected by the consumer. An Expiry Queue holds messages that have passed their time-to-live (TTL) and are no longer valid.

Let's define a DLQ and an Expiry Queue for `my-training-address` to ensure that undeliverable or expired messages are not lost but moved to dedicated queues for inspection.

.Procedure
.  Create a patch file named `add-dlq-expiry.yaml` with the following content. We'll define two new addresses and queues for the DLQ and Expiry, and then link them to `my-training-address` using `deadLetterAddress` and `expiryAddress` within its `addressSettings`.
+
.File: `add-dlq-expiry.yaml`
```yaml
spec:
  addresses:
    # Define the DLQ address and queue
    - name: my-training-dlq-address
      applyToBroker: true
      queues:
        - name: my-training-dlq-queue
          routingType: anycast
          durable: true
    # Define the Expiry Queue address and queue
    - name: my-training-expiry-address
      applyToBroker: true
      queues:
        - name: my-training-expiry-queue
          routingType: anycast
          durable: true
    # Update my-training-address settings to point to the DLQ and Expiry
    - name: my-training-address
      addressSettings:
        - match: my-training-address
          deadLetterAddress: my-training-dlq-address    # Messages failing redelivery will be routed here
          expiryAddress: my-training-expiry-address      # Expired messages will be routed here
          # Other settings from Step 3 are preserved by the merge patch
```
+
.  Apply the patch:
+
.Command
```bash
oc patch activemqartemis amq-broker-sample --type=merge --patch-file=add-dlq-expiry.yaml
```
+
.  Verify the new addresses and the updated `my-training-address` settings:
+
.Command
```bash
oc get activemqartemis amq-broker-sample -o yaml | grep -E "my-training-dlq-address|my-training-expiry-address" -A 10
oc get activemqartemis amq-broker-sample -o yaml | grep -A 5 "my-training-address"
```
+
.Expected Output (Snippet)
You should see the new `my-training-dlq-address` and `my-training-expiry-address` definitions, and the `addressSettings` for `my-training-address` should now include `deadLetterAddress` and `expiryAddress`.
```yaml
    - name: my-training-address
      addressSettings:
      - deadLetterAddress: my-training-dlq-address
        expiryAddress: my-training-expiry-address
        match: my-training-address
        maxDeliveryAttempts: 3
        maxSizeBytes: 10485760
        redeliveryDelay: 5000
```
+
Again, the Hawtio console can provide a visual confirmation of these new addresses and queues under the *Runtime* -> *ActiveMQ Artemis* -> *Addresses* and *Queues* sections.

== Step 5: Configure Message Grouping

Message grouping ensures that all messages belonging to a specific group (identified by a `group-id` header set by the producer) are delivered to the *same* consumer, and in the *order* they were sent, for that group. This is crucial for scenarios requiring strict message processing order or stateful processing (e.g., all messages related to a specific customer order go to one processing instance).

To enable grouping for an address, you typically configure `groupRebalance` and `groupFirstKeyBroadcast` in the `addressSettings`.

*   `groupRebalance: true` allows the broker to rebalance message groups among available consumers if a consumer leaves or joins.
*   `groupFirstKeyBroadcast: true` ensures that when a new message group arrives, the first message of that group is broadcast to all available consumers, allowing them to compete to become the "group leader" for that specific group.

.Procedure
.  Create a patch file named `add-grouping.yaml` to enable grouping settings for `my-training-address`.
+
.File: `add-grouping.yaml`
```yaml
spec:
  addresses:
    - name: my-training-address
      addressSettings:
        - match: my-training-address
          groupRebalance: true             # Enable group rebalancing among consumers
          groupFirstKeyBroadcast: true     # Broadcast the first message of a new group to all consumers to elect a group leader
```
+
.  Apply the patch:
+
.Command
```bash
oc patch activemqartemis amq-broker-sample --type=merge --patch-file=add-grouping.yaml
```
+
.  Verify the updated settings by checking the broker's CR:
+
.Command
```bash
oc get activemqartemis amq-broker-sample -o yaml | grep -A 5 "my-training-address"
```
+
.Expected Output (Snippet)
```yaml
    - name: my-training-address
      addressSettings:
      - deadLetterAddress: my-training-dlq-address
        expiryAddress: my-training-expiry-address
        groupFirstKeyBroadcast: true
        groupRebalance: true
        match: my-training-address
        maxDeliveryAttempts: 3
        maxSizeBytes: 10485760
        redeliveryDelay: 5000
```
+
[NOTE]
While the broker configuration enables grouping, the full effect of message grouping is observed when client applications send messages with a `_AMQ_GroupID` header (or equivalent for the protocol, e.g., `JMSXGroupID` for JMS) and multiple consumers are connected to the queue. The broker will ensure all messages with the same `_AMQ_GroupID` are routed to the same consumer.

== Step 6: Cleanup (Optional)

If you wish to remove the addresses and queues created in this lab, you can modify the `ActiveMQArtemis` CR to remove the `addresses` block or specific address entries.

.Procedure
.  Edit the `ActiveMQArtemis` CR directly using the `oc edit` command:
+
.Command
```bash
oc edit activemqartemis amq-broker-sample
```
+
.  In the editor, navigate to the `spec.addresses` section.
.  Remove the entire `addresses` block or carefully delete the individual address entries (`- name: my-training-address`, `- name: my-training-dlq-address`, `- name: my-training-expiry-address`) along with their nested `queues` and `addressSettings`.
.  Save and exit the editor (`:wq` in Vim, or Ctrl+X then Y then Enter in Nano). The Operator will detect the change and reconfigure the broker, removing the specified addresses and queues.
.  Verify that the addresses and queues are no longer present via `oc get activemqartemis amq-broker-sample -o yaml` or the Hawtio console.

Congratulations! You have successfully configured addresses and queues, including advanced settings like dead letter queues, expiry queues, and message grouping, for your Red Hat AMQ Broker instance on OpenShift. This foundational knowledge is crucial for building robust and reliable messaging applications.