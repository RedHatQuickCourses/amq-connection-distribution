#  Understanding address settings and routing types

ifndef::address-config[]
:address-config:
:amq-broker-version: 7.x
endif::[]

= Understanding Address Settings and Routing Types

The robust message delivery capabilities of Red Hat AMQ Broker are fundamentally governed by how its *addresses* are configured. Addresses act as virtual destinations where producers send messages and from where consumers retrieve them. Beyond simply defining an address, a deeper understanding of its associated *settings* and *routing types* is crucial for building resilient, efficient, and reliable messaging systems. These configurations dictate how messages behave, how they are delivered, and what happens to them under various conditions, such as delivery failures or expiration.

== What are AMQ Broker Address Settings?

Address settings in AMQ Broker allow administrators to define specific behaviors and policies for messages associated with a particular address or a set of addresses. These settings are powerful tools for fine-tuning message persistence, redelivery, expiration, and overall resource management within the broker. They provide granular control over the messaging flow, ensuring messages are handled according to business requirements and operational best practices.

When a message arrives at an address, these predefined settings are applied, influencing its lifecycle within the broker. For example, you can specify how many times a message should be redelivered if a consumer fails to process it, or where expired messages should be sent.

Let's explore some of the most common and impactful address settings:

*   *   `max-size-bytes`:
    *   *Purpose*: This setting defines the maximum cumulative size, in bytes, that all messages in queues bound to this address can occupy.
    *   *Behavior*: If this limit is exceeded, the broker will temporarily block producers from sending new messages to the address until enough messages are consumed to bring the total size below the limit. This prevents an address from consuming all available memory or storage.
    *   *Example*: `100MB` allows messages up to 100 megabytes in total for all queues under the address.

*   *   `expiry-address`:
    *   *Purpose*: Specifies an alternate address to which messages are automatically moved if they expire before being consumed.
    *   *Behavior*: Messages have an `expiration` property. If a message is not consumed before its expiration timestamp, it is moved from its current queue to the queue(s) bound to the `expiry-address`. This is useful for handling time-sensitive data or implementing retry mechanisms.
    *   *Example*: `DLQ.Expiry` could be a dedicated queue for all expired messages.

*   *   `redelivery-delay`:
    *   *Purpose*: Sets the minimum time (in milliseconds) the broker waits before attempting to redeliver a message to a consumer after a previous delivery attempt failed (e.g., due to a transaction rollback or consumer crash).
    *   *Behavior*: This introduces a back-off period, preventing immediate, rapid redelivery attempts that could overwhelm a faulty consumer.
    *   *Example*: `5000` (5 seconds) means the broker will wait at least 5 seconds before retrying delivery.

*   *   `max-redelivery-attempts`:
    *   *Purpose*: Defines the maximum number of times the broker will attempt to redeliver a message to consumers.
    *   *Behavior*: If a message reaches this limit without successful processing, it is typically moved to a `dead-letter-address` to prevent it from indefinitely blocking the queue or consuming resources.
    *   *Example*: `5` means after 5 failed attempts, the message is considered unprocessable and moved.

*   *   `dead-letter-address` (DLQ):
    *   *Purpose*: Specifies an address where messages are moved if they cannot be delivered successfully after `max-redelivery-attempts` have been exhausted, or if they are explicitly sent to the DLQ by an application.
    *   *Behavior*: The DLQ acts as a safe harbor for problematic messages, allowing administrators or applications to inspect them, troubleshoot the issue, and potentially re-process them later.
    *   *Example*: `DLQ` is a common default for dead-letter queues.

*   *   `message-counter-history-day-limit`:
    *   *Purpose*: Configures how many days the broker should retain message count history for management and monitoring purposes.
    *   *Behavior*: This helps manage the amount of data stored for operational statistics.
    *   *Example*: `7` keeps message count history for 7 days.

*   *   `last-value-queue`:
    *   *Purpose*: When set to `true` for a queue, only the last message for a given "key" (specified by a message property) is retained in the queue. Older messages with the same key are replaced.
    *   *Behavior*: Ideal for scenarios where only the most recent state or update is relevant (e.g., stock tickers, sensor readings where only the latest value matters).
    *   *Example*: If messages have a `stock-symbol` property, setting this ensures only the latest price for each symbol is in the queue.

*   *   `auto-create-addresses`, `auto-create-queues`:
    *   *Purpose*: These boolean settings control whether the broker automatically creates addresses or queues when a client attempts to produce to or consume from a non-existent destination.
    *   *Behavior*: Setting them to `true` simplifies client configuration but can lead to unintended resource creation. Setting them to `false` requires explicit pre-configuration, which is often preferred in production environments for better control.

These settings are typically defined within the broker's configuration (e.g., `broker.xml` for standalone, or via the `spec.addresses` section in an AMQ Broker Custom Resource on OpenShift).

[NOTE]
====
When deploying AMQ Broker on OpenShift using the Operator, these address settings are configured within the `spec.addressSettings` array in the `ActiveMQArtemis` Custom Resource (CR). This allows you to declare desired address policies as part of your OpenShift application definition.
====

== Understanding Routing Types

Routing types determine how messages sent to an address are delivered to the queues bound to that address, and subsequently, to the consumers connected to those queues. AMQ Broker supports two primary routing types: `ANYCAST` and `MULTICAST`. The choice of routing type fundamentally shapes the messaging pattern.

=== ANYCAST Routing

*   *Concept*: `ANYCAST` routing implements a *point-to-point* or *work queue* messaging pattern. When a message is sent to an `ANYCAST` address, it is delivered to *only one* of the queues bound to that address, and subsequently consumed by *a single consumer* from that queue.
*   *Behavior*:
    .   A producer sends a message to an `ANYCAST` address.
    .   The broker places the message into *one* of the queues associated with that `ANYCAST` address. If multiple queues are bound, the broker typically uses a load-balancing strategy (e.g., round-robin) to distribute messages among them.
    .   A single consumer connected to any of the queues will receive and process the message.
    .   Once a message is consumed by one client, it is removed from the queue and is not available to other clients.
*   *Use Cases*:
    *   *Work queues*: Distributing tasks among a pool of workers. For example, image processing jobs, order fulfillment, or batch processing.
    *   *Request-reply*: A client sends a request, and a single server processes it and sends back a reply.
    *   *Load balancing*: Spreading processing load across multiple application instances.
*   *Key Characteristics*:
    *   One-to-one message delivery (one message, one consumer).
    *   Messages are consumed destructively (removed from the queue).
    *   Supports durability and persistence for reliable delivery.

image::amq_anycast_routing.png[ANYCAST Routing, 600]
_Figure: ANYCAST Routing - A message sent to an ANYCAST address is delivered to one queue and consumed by a single consumer._

=== MULTICAST Routing

*   *Concept*: `MULTICAST` routing implements a *publish-subscribe* or *broadcast* messaging pattern. When a message is sent to a `MULTICAST` address, it is delivered to *all* queues bound to that address, meaning *all active consumers* on those queues will receive a copy of the message.
*   *Behavior*:
    .   A producer sends a message to a `MULTICAST` address.
    .   The broker creates a *copy* of the message for *each* queue bound to that `MULTICAST` address.
    .   Each consumer connected to these queues receives its own copy of the message.
    .   Messages are consumed independently by each client; consumption by one client does not affect the message's availability to others.
*   *Use Cases*:
    *   *News feeds/Stock tickers*: Broadcasting updates to all interested subscribers.
    *   *Event distribution*: Notifying multiple independent services about an event (e.g., "User Created" event triggering actions in a notification service, an analytics service, and a CRM integration).
    *   *Cache invalidation*: Broadcasting a message to all application instances to clear a specific cached item.
*   *Key Characteristics*:
    *   One-to-many message delivery (one message, multiple consumers, each receiving a copy).
    *   Messages are consumed non-destructively for each subscriber.
    *   Often used for transient, real-time data, but can also be durable if queues are configured as such.

image::amq_multicast_routing.png[MULTICAST Routing, 600]
_Figure: MULTICAST Routing - A message sent to a MULTICAST address is delivered to all bound queues and consumed by all connected consumers._

=== Configuring Routing Types

When defining an address, you explicitly specify its routing type. An address can support both `ANYCAST` and `MULTICAST` routing simultaneously, but they operate independently. For instance, you could have `my.event.topic` as a `MULTICAST` address for publishing events, and `my.service.queue` as an `ANYCAST` address for processing specific tasks.

[TIP]
====
A single AMQ Broker address can be configured to support both `ANYCAST` and `MULTICAST` routing. This means clients can send messages to the same address and define how they want those messages routed based on their client-side configuration or the specific queue they create/attach to. For instance, a client creating a non-durable subscription might receive a `MULTICAST` message, while another client connecting to a named durable queue on the same address might receive an `ANYCAST` message.
====

Understanding these routing types and their corresponding address settings is fundamental for designing effective and reliable messaging solutions with Red Hat AMQ Broker. By judiciously applying these configurations, you can control message flow, ensure delivery guarantees, manage resource usage, and build robust integrations within your OpenShift environment.