#  Understanding Custom Resources (CRs) for AMQ Broker

= Understanding Custom Resources (CRs) for AMQ Broker

This section delves into Custom Resources (CRs) within the context of managing Red Hat AMQ Broker instances on OpenShift. We will explore what CRs are, why they are essential for the AMQ Broker Operator, and how to define and interact with them to deploy and configure your messaging infrastructure.

=== What are Custom Resources?

In the Kubernetes and OpenShift ecosystem, resources like Pods, Deployments, and Services are fundamental building blocks. These are "built-in" resource types that Kubernetes understands out of the box. However, real-world applications often require more complex and domain-specific orchestrations that go beyond these standard types.

Custom Resources (CRs) extend the Kubernetes API, allowing users to define their own resource types. They enable you to represent and manage custom objects in a declarative way, just like you would with built-in Kubernetes resources.

When a Custom Resource Definition (CRD) is applied to a Kubernetes cluster, it tells the cluster about a new kind of object it can store. Once the CRD is available, you can create instances of that custom resource, which are then stored and managed by the Kubernetes API server.

=== The Role of Custom Resources in AMQ Broker Management

The Red Hat AMQ Broker Operator on OpenShift leverages Custom Resources to manage the lifecycle of AMQ Broker instances. Instead of manually creating Pods, Deployments, Services, and other Kubernetes objects for an AMQ Broker, you simply define an `ActiveMQArtemis` custom resource.

The AMQ Broker Operator continuously watches for `ActiveMQArtemis` CRs. When it detects a new CR, an update to an existing one, or a deletion, it takes the necessary actions to bring the actual state of the AMQ Broker infrastructure in line with the desired state defined in the CR. This includes:

*   **Deployment:** Creating the necessary Deployment, StatefulSet, Pods, and Services for the broker instance.
*   **Configuration:** Applying broker-specific configurations like addresses, acceptors, security settings, and persistence.
*   **Scaling:** Adjusting the number of broker pods.
*   **Upgrades:** Managing rolling upgrades.
*   **Monitoring:** Ensuring the broker is healthy and restarting components if needed.

This declarative approach simplifies complex deployments, reduces operational overhead, and ensures consistency across environments.

=== Anatomy of an AMQ Broker Custom Resource

An AMQ Broker Custom Resource is a YAML or JSON file that describes your desired AMQ Broker configuration. The `kind` field for an AMQ Broker instance managed by the Operator is `ActiveMQArtemis`.

Let's break down the key sections of a typical `ActiveMQArtemis` CR:

[source,yaml]
----
apiVersion: broker.amq.io/v1beta1 # <1>
kind: ActiveMQArtemis             # <2>
metadata:                         # <3>
  name: my-amq-broker
  namespace: my-amq-project
spec:                             # <4>
  deploymentPlan:                 # <5>
    size: 1
    image: registry.redhat.io/amq7/amq-broker-rhel8:7.11
    journalType: nio
  acceptors:                      # <6>
    - name: amqp
      protocols: AMQP
      port: 5672
    - name: openwire
      protocols: OPENWIRE
      port: 61616
  addresses:                      # <7>
    - name: my-queue
      routingType: anycast
      queueConfiguration:
        maxConsumers: 1
  securitySettings:               # <8>
    loginModules:
      - name: artemis
        jaasConfig: |
          org.apache.activemq.artemis.spi.core.security.jaas.TextFileLoginModule required
          users.config=etc/artemis-users.properties
          roles.config=etc/artemis-roles.properties;
    users:
      - user: admin
        password: mypassword
      - user: user
        password: password
    roles:
      - name: admin
        users:
          - admin
      - name: amq
        users:
          - admin
          - user
  extraConfigs:                   # <9>
    - name: brokerProperties
      data: |
        messageExpiryScanPeriod=1000
        journal-min-files=10
----
<1> The API version of the Custom Resource Definition. This identifies the version of the API schema the CR adheres to.
<2> The type of the Custom Resource. For AMQ Broker, this is `ActiveMQArtemis`.
<3> Standard Kubernetes metadata, including the `name` of the broker instance and its `namespace`.
<4> The core specification of your AMQ Broker. This is where you define the desired state and configuration.
<5> `deploymentPlan`: Defines the deployment characteristics, such as the number of broker pods (`size`), the container `image` to use, and the `journalType` for message persistence.
<6> `acceptors`: Configures network listeners for different messaging protocols (e.g., AMQP, OpenWire, MQTT, STOMP). Each acceptor defines a name, protocol, and port. This links to the "Acceptor Configuration" objective.
<7> `addresses`: Defines messaging addresses and queues, including routing types (anycast, multicast) and queue-specific settings. This links to the "Address Configuration" objective.
<8> `securitySettings`: Configures authentication and authorization for the broker, including JAAS login modules, user credentials, and roles. This links to the "Security Configuration" objective.
<9> `extraConfigs`: Allows for injecting additional broker configuration, such as custom `brokerProperties` or other configuration files directly into the broker instance.

Many other fields can be configured within the `spec`, aligning with the various objectives mentioned, such as storage configuration, external access settings, and more advanced broker properties.

=== Hands-on Lab: Deploying and Inspecting an AMQ Broker with a Custom Resource

This lab guides you through deploying a basic AMQ Broker instance on OpenShift using its Custom Resource.

==== Prerequisites

*   An active OpenShift cluster.
*   The Red Hat AMQ Broker Operator installed in your OpenShift project. If not installed, please refer to the "Introduction to AMQ Broker Operator on OpenShift" section.
*   `oc` command-line tool configured and logged into your OpenShift cluster.

==== Steps

1.  **Log in to OpenShift and Select Your Project:**

    First, ensure you are logged into your OpenShift cluster and operating within the correct project (namespace). If you don't have a project, create one.

    [source,bash]
    ----
    oc login --token=<your_token> --server=<your_api_server>
    oc new-project amq-broker-test || oc project amq-broker-test
    ----

2.  **Create the AMQ Broker Custom Resource (CR) File:**

    Create a file named `my-broker.yaml` with the following content. This CR defines a single-node AMQ Broker instance.

    [source,yaml]
    ----
    apiVersion: broker.amq.io/v1beta1
    kind: ActiveMQArtemis
    metadata:
      name: my-broker
      namespace: amq-broker-test
    spec:
      deploymentPlan:
        size: 1
        image: registry.redhat.io/amq7/amq-broker-rhel8:7.11 # Ensure this image is accessible
      acceptors:
        - name: amqp
          protocols: AMQP
          port: 5672
        - name: openwire
          protocols: OPENWIRE
          port: 61616
      addresses:
        - name: my-test-queue
          routingType: anycast
          queueConfiguration:
            maxConsumers: 1
      securitySettings:
        loginModules:
          - name: artemis
            jaasConfig: |
              org.apache.activemq.artemis.spi.core.security.jaas.TextFileLoginModule required
              users.config=etc/artemis-users.properties
              roles.config=etc/artemis-roles.properties;
        users:
          - user: admin
            password: password123
        roles:
          - name: amq
            users:
              - admin
    ----

    *Self-Correction/Note*: The `image` used above (`registry.redhat.io/amq7/amq-broker-rhel8:7.11`) requires authentication against `registry.redhat.io`. In a production environment, you might need to configure image pull secrets. For this lab, assume the cluster or project is configured to pull from Red Hat's registry. Alternatively, use an unauthenticated public image if available for quick testing, but the Red Hat image is recommended for consistency.

3.  **Apply the Custom Resource:**

    Use the `oc apply` command to create the AMQ Broker instance based on your `my-broker.yaml` file.

    [source,bash]
    ----
    oc apply -f my-broker.yaml
    ----
    Expected Output:
    ```
    activemqartemis.broker.amq.io/my-broker created
    ```

4.  **Verify the AMQ Broker Deployment:**

    The AMQ Broker Operator will now start provisioning the necessary OpenShift resources. You can observe its progress:

    *   **Check the `ActiveMQArtemis` CR status:**

        [source,bash]
        ----
        oc get activemqartemis my-broker -o yaml
        ----
        Look for the `status` section in the output. It will indicate whether the broker is `Running`, `Pending`, or `Failed`.

    *   **List the pods:**

        [source,bash]
        ----
        oc get pods -l app=my-broker
        ----
        You should see a pod named `my-broker-ss-0` (or similar) eventually transitioning to `Running` state.

    *   **List the services:**

        [source,bash]
        ----
        oc get services -l app=my-broker
        ----
        You should see services created for the broker's internal communication and client access (e.g., `my-broker-amqp`, `my-broker-openwire`).

5.  **Describe the Custom Resource:**

    To get more detailed information about the broker instance, including events and conditions managed by the Operator, you can `describe` the CR.

    [source,bash]
    ----
    oc describe activemqartemis my-broker
    ----
    This output will show you the configured `spec`, the current `status` (including ready replicas, image used, etc.), and recent events related to the Operator's actions on this CR.

6.  **(Optional) Modify and Observe the CR Update:**

    Let's modify the CR to add another simple address.

    *   **Edit `my-broker.yaml`:**
        Add the following entry under the `addresses` section:

        [source,yaml]
        ----
        # ... (previous content) ...
          addresses:
            - name: my-test-queue
              routingType: anycast
              queueConfiguration:
                maxConsumers: 1
            - name: another-queue # <1>
              routingType: anycast
        ----
        <1> New address added.

    *   **Apply the updated CR:**

        [source,bash]
        ----
        oc apply -f my-broker.yaml
        ----
        Expected Output:
        ```
        activemqartemis.broker.amq.io/my-broker configured
        ```

    *   **Observe Operator Reconciliation:**
        The Operator will detect the change in the CR and reconcile the broker instance. You won't typically see a pod restart for simple configuration changes like adding an address, as the Operator will update the broker's configuration dynamically. You can verify the change by connecting to the broker or inspecting its configuration through its management interface (if exposed).

This lab demonstrates the power of Custom Resources: you define *what* you want (the desired state), and the Operator handles *how* to achieve and maintain that state on OpenShift. This declarative model is central to managing AMQ Broker effectively in a cloud-native environment.