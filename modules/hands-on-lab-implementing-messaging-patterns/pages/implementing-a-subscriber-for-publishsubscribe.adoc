#  Implementing a subscriber for Publish/Subscribe

= Implementing a Subscriber for Publish/Subscribe

This section will guide you through the process of implementing a subscriber for the Publish/Subscribe (Pub/Sub) messaging model. A subscriber's primary role is to express interest in specific message topics and consume messages published to those topics. This is a crucial component in achieving highly decoupled and scalable distributed systems, enabling multiple consumers to receive the same message from a single publisher.

== Understanding the Publish/Subscribe Subscriber

[.lead]
In the Pub/Sub model, a *subscriber* is a component that registers its interest in one or more *topics* with a message broker. When a *publisher* sends a message to a particular topic, the broker ensures that all active subscribers to that topic receive a copy of the message. This mechanism allows for a "fan-out" pattern, where one message can be delivered to many interested parties simultaneously.

Unlike the Point-to-Point (PTP) model where each message is delivered to only one consumer, Pub/Sub allows for multiple consumers to process the same message, making it ideal for scenarios like broadcasting events, real-time data streaming, logging, or notification services.

Key characteristics of a Pub/Sub subscriber:

*   *Topic-based interest*: Subscribers don't care who sent the message, only what topic it belongs to.
*   *Asynchronous consumption*: Subscribers typically listen continuously for new messages without blocking the publisher.
*   *Decoupling*: Publishers and subscribers have no direct knowledge of each other, communicating solely through the broker and topics.

The message broker plays a vital role here by managing subscriptions and routing messages efficiently to all relevant subscribers.

== Hands-on Lab: Implementing a Subscriber for Publish/Subscribe

In this lab, you will develop a Python-based subscriber application. This application will connect to our message broker, subscribe to a specific topic, and then continuously listen for and process messages published to that topic.

[NOTE]
This lab assumes you have successfully completed the "Setting up a basic message broker" and "Implementing a publisher for Publish/Subscribe" labs, and that your message broker is running and accessible. We'll use a generic `message_broker_client` concept for clarity, which can be adapted to specific broker technologies like RabbitMQ (using `pika`), Kafka (using `confluent-kafka-python`), or Redis Pub/Sub.

=== Prerequisites

Before you begin, ensure you have:

*   A running message broker (e.g., RabbitMQ, Kafka, Redis).
*   Python 3.x installed on your system.
*   The necessary client library for your chosen broker installed (e.g., `pip install pika` for RabbitMQ). For this example, we'll simulate a generic client.

=== Step 1: Create the Subscriber Script

Let's create a new Python file named `subscriber.py`. This file will contain the logic for our subscriber.

Create the file:
[source,bash]
----
touch subscriber.py
----

Open `subscriber.py` in your favorite text editor.

=== Step 2: Define the Message Processing Logic

The core of any subscriber is the function that gets called when a new message arrives. This function, often called a `callback` or `message_handler`, is where you'll implement the business logic to process the received message.

Add the following code to `subscriber.py`:

[source,python]
----
import time
import json
# For a real application, replace this with your actual message broker client library
# For example, for RabbitMQ: import pika
# For Kafka: from confluent_kafka import Consumer, KafkaException

# --- Generic/Simulated Message Broker Client (for demonstration) ---
# In a real scenario, you would use a library like pika, confluent_kafka, etc.
class GenericMessageBrokerClient:
    def __init__(self, host='localhost', port=5672, client_id=""):
        self.host = host
        self.port = port
        self.client_id = client_id
        self.connection = None
        self.channel = None
        print(f"[{self.client_id}] Initializing generic broker client for {host}:{port}")

    def connect(self):
        # Simulate connection
        print(f"[{self.client_id}] Connecting to broker at {self.host}:{self.port}...")
        time.sleep(1) # Simulate network delay
        self.connection = True # Placeholder for actual connection object
        self.channel = True # Placeholder for actual channel object
        print(f"[{self.client_id}] Connection established.")
        return True

    def subscribe(self, topic_name, callback_function):
        if not self.connection:
            print(f"[{self.client_id}] Error: Not connected to broker.")
            return False
        print(f"[{self.client_id}] Subscribing to topic: '{topic_name}'...")
        # In a real client, this would set up the actual subscription.
        # For simulation, we'll store the callback and topic.
        self._callback = callback_function
        self._topic = topic_name
        print(f"[{self.client_id}] Successfully subscribed to '{topic_name}'.")
        return True

    def start_consuming(self):
        if not self.connection:
            print(f"[{self.client_id}] Error: Not connected to broker.")
            return

        print(f"[{self.client_id}] Waiting for messages on topic '{self._topic}'. To exit press CTRL+C")
        try:
            # Simulate continuous listening
            while True:
                # In a real broker client, this loop would block or poll for messages
                # and then invoke the callback.
                time.sleep(1) # Simulate polling interval
        except KeyboardInterrupt:
            print(f"[{self.client_id}] Disconnecting...")
        finally:
            self.disconnect()

    def disconnect(self):
        if self.connection:
            print(f"[{self.client_id}] Disconnecting from broker...")
            # Simulate disconnection
            self.connection = None
            self.channel = None
            print(f"[{self.client_id}] Disconnected.")

# -------------------------------------------------------------------

def message_callback(message_body):
    """
    This function will be called whenever a message is received.
    It takes the raw message body as input.
    """
    try:
        # Assuming messages are JSON encoded
        message_data = json.loads(message_body)
        print(f" [x] Received event: {message_data.get('event_type')}")
        print(f"     Payload: {message_data.get('payload')}")
        # Simulate some processing time
        time.sleep(0.5)
        print(" [x] Message processed.")
    except json.JSONDecodeError:
        print(f" [x] Received non-JSON message: {message_body}")
    except Exception as e:
        print(f" [!] Error processing message: {e}")

if __name__ == "__main__":
    # Configure your subscriber
    BROKER_HOST = 'localhost'
    BROKER_PORT = 5672 # Default for RabbitMQ
    TOPIC_NAME = 'sensor.data' # The topic we want to subscribe to

    # Create a subscriber instance
    subscriber = GenericMessageBrokerClient(BROKER_HOST, BROKER_PORT, client_id="DataSubscriber1")

    # 1. Connect to the message broker
    if not subscriber.connect():
        print("Failed to connect to the broker. Exiting.")
        exit(1)

    # 2. Subscribe to the desired topic
    # Note: In real clients, you might pass a specific queue name or allow the client to create one.
    # The crucial part is binding this queue to the 'sensor.data' topic/exchange.
    if not subscriber.subscribe(TOPIC_NAME, message_callback):
        print(f"Failed to subscribe to topic '{TOPIC_NAME}'. Exiting.")
        subscriber.disconnect()
        exit(1)

    # 3. Start consuming messages
    print(f"Waiting for messages on topic '{TOPIC_NAME}'. To exit press CTRL+C")
    subscriber.start_consuming()

    print("Subscriber application exited.")
----

=== Step 3: Understand the Code

Let's break down the key parts of the subscriber code:

*   **`GenericMessageBrokerClient` (Simulated):** This class is a stand-in for a real message broker client library (like `pika` for RabbitMQ). It encapsulates connection, subscription, and message consumption logic. In a production environment, you would replace this with the appropriate library for your broker.
*   **`message_callback(message_body)` function:**
    *   This is the heart of our subscriber. It's designed to be executed every time the subscriber receives a message from the subscribed topic.
    *   It expects the `message_body` to be a string, which we then attempt to parse as JSON. This is a common practice for structured data.
    *   Inside this function, you would place your application-specific logic to process the data (e.g., store it in a database, trigger another service, update a dashboard).
*   **`if __name__ == "__main__":` block:**
    *   This is the entry point of our script.
    *   It defines the `BROKER_HOST`, `BROKER_PORT`, and `TOPIC_NAME` â€“ essential configuration details.
    *   It initializes `GenericMessageBrokerClient`.
    *   **`subscriber.connect()`:** Establishes a connection to the message broker. Without a connection, no messages can be sent or received.
    *   **`subscriber.subscribe(TOPIC_NAME, message_callback)`:** This is where the subscriber registers its interest. It tells the broker: "I want to receive all messages sent to `TOPIC_NAME`, and when I get one, please call my `message_callback` function."
    *   **`subscriber.start_consuming()`:** This method enters a loop that continuously listens for incoming messages. It will keep the subscriber application running until explicitly stopped (e.g., by pressing `Ctrl+C`).

=== Step 4: Run the Subscriber

Open a terminal and navigate to the directory where you saved `subscriber.py`.

Execute the subscriber script:
[source,bash]
----
python subscriber.py
----

You should see output similar to this, indicating the subscriber is connected and waiting for messages:

[source,console]
----
[DataSubscriber1] Initializing generic broker client for localhost:5672
[DataSubscriber1] Connecting to broker at localhost:5672...
[DataSubscriber1] Connection established.
[DataSubscriber1] Subscribing to topic: 'sensor.data'...
[DataSubscriber1] Successfully subscribed to 'sensor.data'.
Waiting for messages on topic 'sensor.data'. To exit press CTRL+C
[DataSubscriber1] Waiting for messages on topic 'sensor.data'. To exit press CTRL+C
----

Leave this terminal window open.

=== Step 5: Test with a Publisher

Now, open a *second* terminal window. In this terminal, run your publisher application (from the "Implementing a publisher for Publish/Subscribe" lab) which sends messages to the `sensor.data` topic.

Execute the publisher script (assuming it's named `publisher.py`):
[source,bash]
----
python publisher.py
----

You should see the publisher sending messages:

[source,console]
----
[EventPublisher] Initializing generic broker client for localhost:5672
[EventPublisher] Connecting to broker at localhost:5672...
[EventPublisher] Connection established.
[EventPublisher] Declaring topic 'sensor.data'...
[EventPublisher] Topic 'sensor.data' ready.
[EventPublisher] Publishing message to 'sensor.data': {"event_type": "temperature_reading", "payload": {"device_id": "sensor-123", "temperature_c": 22.5, "timestamp": "2023-10-27T10:00:00Z"}}
[EventPublisher] Publishing message to 'sensor.data': {"event_type": "humidity_reading", "payload": {"device_id": "sensor-124", "humidity_percent": 65.2, "timestamp": "2023-10-27T10:00:01Z"}}
...
----

Simultaneously, observe the output in your *first* terminal window (where the subscriber is running). You should see the subscriber receiving and processing each message:

[source,console]
----
[DataSubscriber1] Waiting for messages on topic 'sensor.data'. To exit press CTRL+C
 [x] Received event: temperature_reading
     Payload: {'device_id': 'sensor-123', 'temperature_c': 22.5, 'timestamp': '2023-10-27T10:00:00Z'}
 [x] Message processed.
 [x] Received event: humidity_reading
     Payload: {'device_id': 'sensor-124', 'humidity_percent': 65.2, 'timestamp': '2023-10-27T10:00:01Z'}
 [x] Message processed.
----

This confirms that your subscriber is successfully connecting to the broker, subscribing to the specified topic, and receiving messages published to that topic.

=== Step 6: Test with Multiple Subscribers (Optional)

To fully appreciate the fan-out capability of Pub/Sub, you can run multiple instances of the `subscriber.py` script.

1.  Open a *third* terminal window.
2.  Run the subscriber script again in this new terminal:
    [source,bash]
    ----
    python subscriber.py
    ----
    You will have two subscribers running concurrently.
3.  Go back to your publisher terminal and run the publisher script again.

Observe both subscriber terminals. You will see *both* subscribers receiving and processing *every* message published by the publisher. This demonstrates how Pub/Sub enables one-to-many communication efficiently.

[NOTE]
If you are using a real broker like RabbitMQ, each subscriber will typically create its own exclusive queue that is bound to the exchange (topic). This ensures that each subscriber gets its own copy of all messages published to that exchange.

=== Troubleshooting Tips

*   *Broker not running*: Ensure your message broker service is active and accessible. Check its logs for errors.
*   *Connection Refused*: This usually means the subscriber cannot reach the broker. Verify the `BROKER_HOST` and `BROKER_PORT` are correct, and that no firewall is blocking the connection.
*   *Messages not received*:
    *   Double-check that the `TOPIC_NAME` in your publisher and subscriber match exactly.
    *   Ensure the publisher is actually sending messages.
    *   Verify the broker's management interface (if available) to see if messages are flowing to the topic/exchange.
*   *Library specific issues*: If using a real library like `pika` or `confluent-kafka-python`, refer to their documentation for specific connection and subscription parameters, especially for error handling and retries.
*   *Callback errors*: If your `message_callback` function has an error, it might stop processing subsequent messages depending on the broker client library. Implement robust error handling within your callback.

You have now successfully implemented a subscriber for the Publish/Subscribe messaging model, demonstrating its ability to consume messages from a specific topic and enable one-to-many communication in a distributed system.