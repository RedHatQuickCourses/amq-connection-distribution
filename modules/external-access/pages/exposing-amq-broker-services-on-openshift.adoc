#  Exposing AMQ Broker services on OpenShift

This module focuses on making your Red Hat AMQ Broker instances, running within an OpenShift cluster, accessible to external client applications. While applications within the same OpenShift project or cluster can easily communicate with the broker using internal service names, external clients require specific mechanisms to establish connectivity securely and reliably.

== The Need for External Access

When you deploy AMQ Broker on OpenShift, it typically runs as a pod, and its network communication is managed by OpenShift's internal networking. By default, these services are not directly reachable from outside the cluster. However, most real-world message-oriented middleware deployments involve clients located outside the OpenShift cluster—on-premise applications, other cloud environments, or external microservices—that need to connect to the broker to send and receive messages.

This section details the primary OpenShift constructs available for exposing internal services, specifically your AMQ Broker, to the outside world.

== OpenShift Mechanisms for External Exposure

OpenShift provides several mechanisms to expose services externally, each with its own use cases and characteristics. For AMQ Broker, the most common and robust methods are OpenShift Routes, followed by LoadBalancer and NodePort services.

=== OpenShift Routes

OpenShift Routes are the primary method for exposing HTTP/HTTPS and even non-HTTP (via `passthrough`) services running within the cluster to external clients. They provide a publicly resolvable hostname and act as an entry point, directing external traffic to the correct service within your OpenShift cluster.

Routes are typically handled by the OpenShift Router component (often an HAProxy instance), which performs intelligent load balancing, TLS termination, and traffic distribution.

==== Key Features of OpenShift Routes for AMQ Broker

*   **Public Hostname:** Routes provide a stable, DNS-resolvable hostname for your AMQ Broker.
*   **Load Balancing:** The OpenShift Router can distribute incoming connections across multiple AMQ Broker pods if you have a highly available deployment.
*   **TLS Termination:** Routes can handle SSL/TLS termination, re-encryption, or passthrough, which is crucial for secure messaging protocols.
*   **Traffic Management:** Supports various routing policies and path-based routing, although less relevant for direct AMQ Broker connectivity.

==== Route Types for AMQ Broker

When exposing AMQ Broker, especially for non-HTTP protocols like AMQP, MQTT, OpenWire, and STOMP, the choice of Route type is critical for handling TLS correctly:

*   **`passthrough`:** This is the most common and recommended type for AMQ Broker with TLS. In `passthrough` routing, the router does not decrypt the traffic. Instead, it directly passes the encrypted TLS connection to the backend service (your AMQ Broker pod). This means the AMQ Broker itself must be configured to handle TLS encryption and decryption. This ensures end-to-end encryption from the client to the broker.

    .Example `passthrough` Route
    [source,yaml]
    ----
    apiVersion: route.openshift.io/v1
    kind: Route
    metadata:
      name: my-broker-amqps-passthrough
      namespace: my-amq-project
    spec:
      host: amqps.mybroker.example.com
      to:
        kind: Service
        name: my-broker-amqp-service # Name of the OpenShift Service pointing to your AMQ Broker pods
        weight: 100
      port:
        targetPort: amqps # Target port name as defined in the Service
      tls:
        termination: passthrough
        insecureEdgeTerminationPolicy: Redirect # Or 'None' if you don't want redirection
    ----

*   **`reencrypt`:** In `reencrypt` routing, the router decrypts the incoming TLS connection from the client, then re-encrypts it using a different certificate before sending it to the backend service. This can be useful if you want to manage external certificates at the router level and internal certificates at the broker level separately. However, it requires more configuration and careful certificate management. The broker must also be configured for TLS.

    .Example `reencrypt` Route
    [source,yaml]
    ----
    apiVersion: route.openshift.io/v1
    kind: Route
    metadata:
      name: my-broker-amqps-reencrypt
      namespace: my-amq-project
    spec:
      host: amqps-reencrypt.mybroker.example.com
      to:
        kind: Service
        name: my-broker-amqp-service
        weight: 100
      port:
        targetPort: amqps
      tls:
        termination: reencrypt
        insecureEdgeTerminationPolicy: Redirect
        certificate: | # External-facing certificate for the router
          -----BEGIN CERTIFICATE-----
          ...
          -----END CERTIFICATE-----
        key: | # Private key for the router's external certificate
          -----BEGIN RSA PRIVATE KEY-----
          ...
          -----END RSA PRIVATE KEY-----
        destinationCACertificate: | # CA certificate for the backend service (broker)
          -----BEGIN CERTIFICATE-----
          ...
          -----END CERTIFICATE-----
    ----

    [NOTE]
    For AMQ Broker, `passthrough` is generally preferred for simpler end-to-end TLS configuration, especially for protocols like AMQP, MQTT, OpenWire, and STOMP, which expect a raw TLS tunnel. `reencrypt` is more common for HTTP/HTTPS applications.

*   **`edge`:** This type performs TLS termination at the router, and then traffic is sent unencrypted to the backend service. This is generally *not recommended* for AMQ Broker due to the lack of end-to-end encryption, unless the entire network path within OpenShift is considered highly secure and isolated.

=== Service of Type `LoadBalancer`

If your OpenShift cluster is running on a cloud provider (e.g., AWS, Azure, GCP), you can use a `Service` of type `LoadBalancer` to expose your AMQ Broker. This type of service requests a load balancer from the underlying cloud infrastructure, which then forwards external traffic to your service within OpenShift.

==== Key Features of `LoadBalancer` Services

*   **External IP Address:** The cloud provider provisions an external, stable IP address or hostname for the load balancer.
*   **Protocol Agnostic:** Can expose any TCP/UDP port, making it suitable for AMQ Broker's various protocols.
*   **Cloud Provider Integration:** Leverages cloud provider's native load balancing capabilities.

==== When to use `LoadBalancer`

*   When you need a dedicated external IP address for your broker.
*   When your OpenShift environment is on a cloud provider that supports `LoadBalancer` services.
*   When you prefer cloud provider's native load balancing over OpenShift's router for specific reasons.

.Example `LoadBalancer` Service
[source,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: my-broker-loadbalancer
  namespace: my-amq-project
spec:
  selector:
    app.kubernetes.io/name: my-amq-broker # Label selector matching your AMQ Broker pods
  ports:
    - protocol: TCP
      port: 5671 # The port external clients will connect to
      targetPort: 5671 # The port on the AMQ Broker pod
      name: amqps
  type: LoadBalancer
----

[NOTE]
If you use a `LoadBalancer` service, the TLS termination (if any) will typically happen at the AMQ Broker itself, or you might configure the cloud provider's load balancer for TLS passthrough or termination before forwarding to the broker.

=== Service of Type `NodePort`

A `Service` of type `NodePort` exposes the service on a static port on each node's IP address within the cluster. This means you can access the AMQ Broker by connecting to `<NodeIP>:<NodePort>` from outside the cluster.

==== Key Features of `NodePort` Services

*   **Direct Node Access:** Provides a direct way to access services via cluster nodes.
*   **Always Available:** The service is available on *every* node, regardless of which node the pod is running on.
*   **Simplicity (for testing):** Easy to set up for basic testing or development.

==== When to use `NodePort`

*   For testing or development environments where a simple, direct access method is sufficient.
*   In environments where `LoadBalancer` services are not available (e.g., bare-metal OpenShift without a dedicated load balancer integration) and `Routes` are not suitable for the protocol.

==== Drawbacks of `NodePort`

*   **Requires Node IP Knowledge:** Clients need to know the IP address of one of the cluster nodes, which can change.
*   **Port Collision Risk:** You must manage the `NodePort` to avoid conflicts.
*   **No Load Balancing:** Requires an external load balancer in front of the cluster nodes for production use.
*   **Security Concerns:** Exposes a port on *all* nodes, potentially increasing the attack surface if not properly secured with external firewalls.

.Example `NodePort` Service
[source,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: my-broker-nodeport
  namespace: my-amq-project
spec:
  selector:
    app.kubernetes.io/name: my-amq-broker
  ports:
    - protocol: TCP
      port: 5671
      targetPort: 5671
      nodePort: 30001 # An available port in the NodePort range (e.g., 30000-32767)
      name: amqps
  type: NodePort
----

== Securing External Access

Exposing AMQ Broker externally inherently introduces security considerations. It's crucial to implement robust security measures to protect your messaging infrastructure.

=== SSL/TLS for Secure Communication

Regardless of the exposure mechanism (Route, LoadBalancer, NodePort), always configure AMQ Broker for SSL/TLS to encrypt data in transit.

*   **With `passthrough` Routes:** The AMQ Broker must be fully configured to handle TLS using its certificates and private keys. The client connects to the Route's hostname, and the encrypted traffic passes through the router to the broker.
*   **With `reencrypt` Routes:** The router handles the initial client-side TLS termination, then re-encrypts traffic to the broker. Both the router and the broker require proper certificate configuration.
*   **With `LoadBalancer` or `NodePort` Services:** The AMQ Broker handles TLS termination directly. It's essential that the broker is configured with valid certificates trusted by the external clients.

Refer to the "Security Configuration" module for detailed instructions on configuring SSL/TLS within AMQ Broker itself.

=== OpenShift Network Policies

OpenShift `NetworkPolicies` provide granular control over network traffic within the cluster. When exposing services externally, `NetworkPolicies` can be used to restrict which pods or namespaces are allowed to communicate with your AMQ Broker, even if it's externally accessible.

While `NetworkPolicies` primarily manage *internal* ingress/egress, they complement external security by ensuring that only authorized internal components can interact with the broker once traffic enters the cluster. For restricting specific external IP ranges connecting to a Route, you typically configure this at the OpenShift Router level (if your router implementation supports it, e.g., via annotations or a custom configuration) or by implementing external firewall rules. NetworkPolicies, on the other hand, manage traffic *within* the OpenShift cluster, controlling which pods can communicate with your broker once the traffic has entered the cluster via a Route or Service.

.Example NetworkPolicy (allowing ingress only from specific namespaces)
[source,yaml]
----
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-internal-amq-clients
  namespace: my-amq-project
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/name: my-amq-broker
  policyTypes:
    - Ingress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              project: amq-client-apps # Only allow clients from this project
      ports:
        - protocol: TCP
          port: 5671 # The AMQPS port
----

== Expert Insights and Troubleshooting

*   **DNS Resolution:** Ensure that the hostname provided by an OpenShift Route is correctly resolvable by your external clients. This often involves configuring public DNS records to point to your OpenShift Router's external IP address.
*   **Firewall Rules:** If your OpenShift cluster is behind an external firewall (e.g., corporate firewall, cloud security groups), ensure that the necessary ports (e.g., 443 for HTTPS/passthrough Routes, or custom ports for NodePorts/LoadBalancers) are open to allow incoming client connections.
*   **Route `termination`:** Misconfiguring the `termination` type for Routes is a common issue. If clients are expecting end-to-end TLS and you use `edge` termination, or if the broker isn't configured for TLS and you use `passthrough`, connectivity will fail.
*   **Service Selector:** Always verify that the `selector` in your OpenShift Service correctly matches the labels of your AMQ Broker pods. If the selector is incorrect, the service won't route traffic to the pods.
*   **Protocol Port Mapping:** Ensure that the `port` and `targetPort` in your Service and Route definitions correctly map the external port to the internal port where AMQ Broker is listening for a specific protocol.
*   **Operator-Managed Services:** When using the AMQ Broker Operator, the Operator often manages the creation of Services for the broker. You'll typically create Routes that point to these Operator-managed Services.

== Hands-on Lab: Exposing AMQ Broker Externally

In this lab, you will configure an OpenShift Route to expose an existing AMQ Broker instance, enabling external clients to connect securely. We will focus on using a `passthrough` Route for AMQPS (AMQP over TLS), a common setup for secure AMQ Broker access.

=== Objective

*   Expose an existing AMQ Broker service using an OpenShift `Route`.
*   Verify external connectivity to the broker using a client tool.

=== Prerequisites

*   An OpenShift cluster with `oc` CLI configured.
*   An AMQ Broker instance already deployed and running in an OpenShift project (e.g., `my-amq-project`).
*   The AMQ Broker instance must be configured for TLS on its AMQP acceptor (port 5671, for example). Refer to the "Security Configuration" module if needed.
*   Knowledge of your OpenShift Router's external IP or DNS wildcard configuration.
*   A client tool capable of connecting to AMQP over TLS (e.g., Apache Qpid Proton C/J, JMS client, or a simple Python `qpid-proton` script).

=== Steps

.  **Identify the AMQ Broker Service:**
    First, determine the name of the OpenShift `Service` that targets your AMQ Broker pods and the port name (or number) for the AMQPS protocol.

    [source,bash]
    ----
    oc get services -n my-amq-project
    # Look for a service name like 'my-broker-amqps-service' and note its port name, e.g., 'amqps'.
    ----

.  **Create a `passthrough` Route:**
    Create a `Route` that points to your AMQ Broker's TLS-enabled service. Replace `amqps.yourcluster.example.com` with a suitable hostname resolvable by your external clients and configured in your DNS to point to your OpenShift router.

    [source,yaml]
    ----
    # route.yaml
    apiVersion: route.openshift.io/v1
    kind: Route
    metadata:
      name: my-broker-external-amqps
      namespace: my-amq-project
    spec:
      host: amqps.yourcluster.example.com # Replace with your external hostname
      to:
        kind: Service
        name: my-broker-amqps-service # Replace with your AMQ Broker Service name
        weight: 100
      port:
        targetPort: amqps # Replace with the correct port name from your Service
      tls:
        termination: passthrough
        insecureEdgeTerminationPolicy: Redirect
    ----

    Apply the Route:

    [source,bash]
    ----
    oc apply -f route.yaml -n my-amq-project
    ----

.  **Verify the Route Status:**
    Check that the Route has been created and is active.

    [source,bash]
    ----
    oc get route my-broker-external-amqps -n my-amq-project
    # Look for the 'HOST/PORT' column, which should show your external hostname.
    ----

.  **Configure External DNS (if necessary):**
    Ensure that `amqps.yourcluster.example.com` (or your chosen hostname) resolves to the external IP address of your OpenShift router. This step is outside OpenShift but critical for external access. Consult your DNS provider's documentation.

.  **Test External Connectivity:**
    Use an AMQP client from *outside* the OpenShift cluster to connect to the new Route.

    [NOTE]
    You will need a client application that can connect to AMQP over TLS. The client must trust the certificate presented by the AMQ Broker. Ensure you have the necessary client trust store configured, which typically involves providing the broker's CA certificate to the client.

    .Example Python `qpid-proton` client snippet (conceptual for sending)
    [source,python]
    ----
    from proton import Messenger
    from proton.handlers import MessagingHandler
    from proton.utils import ProtonException

    class Send(MessagingHandler):
        def __init__(self, url):
            super(Send, self).__init__()
            self.url = url

        def on_start(self, event):
            event.container.create_sender(self.url)

        def on_sendable(self, event):
            message = event.message
            message.address = "my_queue" # Replace with your target queue name
            message.body = "Hello AMQ Broker from outside OpenShift!"
            event.sender.send(message)
            print(f"Sent: {message.body}")
            event.sender.close()
            event.connection.close()

    try:
        # Replace with your Route's hostname and the desired queue
        client_url = "amqps://<username>:<password>@amqps.yourcluster.example.com:443/my_queue"
        print(f"Attempting to connect to: {client_url}")

        # Instantiate a messenger for sending
        m = Messenger()
        m.start()

        # You might need to configure TLS options here, e.g., m.ssl_client_options()
        # For qpid-proton, this often means setting environment variables (e.g., PN_TLS_TRUST_FILE)
        # or configuring SSL/TLS client options directly if the library supports it.
        # For simplicity, this example assumes a basic TLS setup where the client
        # trusts a public CA or has a trust store configured for the broker's certificate.

        # For a simple send test:
        # container = Container(Send(client_url))
        # container.run()
        print("Successfully connected and sent messages (conceptual, client setup required).")

    except ProtonException as e:
        print(f"Connection failed: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
    ----

    Replace `amqps.yourcluster.example.com` with your actual Route hostname, `my_queue` with a valid queue on your broker, and provide correct credentials. Ensure your client application is configured to trust the TLS certificate presented by the broker via the `passthrough` Route.

.  **Clean Up (Optional):**
    If this was a test, you can remove the Route.

    [source,bash]
    ----
    oc delete route my-broker-external-amqps -n my-amq-project
    ----