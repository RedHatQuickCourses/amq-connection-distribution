#  Setting up SSL/TLS for secure client connections

This content is presented in Antora AsciiDoc format.

[role="doc-wrapper"]
= Setting up SSL/TLS for Secure Client Connections

This section details the critical process of securing client connections to Red Hat AMQ Broker on OpenShift using SSL/TLS. We will cover the underlying concepts, configuration steps, and a practical hands-on lab to implement secure communication for your messaging infrastructure.

== Understanding Secure Sockets Layer (SSL) / Transport Layer Security (TLS)

In the realm of network communication, especially for sensitive data exchange, securing the communication channel is paramount. SSL (Secure Sockets Layer) and its successor, TLS (Transport Layer Security), are cryptographic protocols designed to provide secure communication over a computer network. They ensure data privacy, integrity, and authenticity between communicating applications, such as an AMQ Broker instance and its client applications.

When a client connects to an AMQ Broker instance configured with SSL/TLS, the following high-level steps occur:

.  **Handshake:** The client and broker initiate a handshake process to establish a secure session. This involves:
    *   **Cipher Suite Negotiation:** Agreeing on cryptographic algorithms to be used for encryption, hashing, and key exchange.
    *   **Server Authentication:** The broker presents its digital certificate to the client. The client validates this certificate against its trusted root Certificate Authorities (CAs) to verify the broker's identity. This prevents "man-in-the-middle" attacks.
    *   **Key Exchange:** Securely exchanging session keys that will be used for symmetric encryption of the actual data.
.  **Data Transfer:** Once the handshake is complete, all subsequent data exchanged between the client and the broker is encrypted using the agreed-upon session keys, ensuring confidentiality and integrity.

For AMQ Broker, securing client connections primarily involves configuring acceptors to listen on SSL/TLS-enabled ports and providing the necessary cryptographic materials (certificates and keys).

=== Key Concepts for SSL/TLS Configuration

To successfully implement SSL/TLS, it's essential to understand a few core concepts:

*   **Digital Certificates:** These are electronic documents used to prove the ownership of a public key. They are issued by Certificate Authorities (CAs) and contain information about the certificate owner (e.g., broker's hostname), the public key, the CA's digital signature, and validity dates.
*   **Public Key Infrastructure (PKI):** A set of roles, policies, and procedures needed to create, manage, distribute, use, store, and revoke digital certificates.
*   **Keystore:** A file that stores private keys and their associated public key certificates. For AMQ Broker, the keystore holds the broker's identity (its private key and certificate chain) that it presents to clients.
*   **Truststore:** A file that stores certificates from trusted Certificate Authorities (CAs) or directly trusted public keys. Clients use a truststore to verify the authenticity of the server's certificate. Similarly, if mutual TLS (client authentication) is enabled, the broker uses its truststore to verify client certificates.
*   **Private Key:** A secret cryptographic key that must be kept confidential. It is mathematically linked to a public key and is used for decryption and digital signing.
*   **Public Key:** A cryptographic key that can be freely shared. It is used for encryption and verifying digital signatures.

=== AMQ Broker Acceptor Configuration for SSL/TLS

AMQ Broker uses *acceptors* to listen for incoming client connections. To enable SSL/TLS for an acceptor, you typically configure specific parameters within the broker's configuration, which, when deploying on OpenShift, is managed via a Custom Resource (CR).

Key configuration elements for an SSL/TLS-enabled acceptor include:

*   `sslEnabled`: A boolean flag to enable or disable SSL/TLS for the acceptor.
*   `sslEnabledProtocols`: Specifies the TLS protocols to enable (e.g., `TLSv1.2,TLSv1.3`).
*   `keyStorePath`: The path to the broker's keystore file.
*   `keyStorePassword`: The password for the keystore.
*   `trustStorePath`: (Optional, for mutual TLS) The path to the broker's truststore file.
*   `trustStorePassword`: (Optional) The password for the truststore.
*   `wantClientAuth`: (Optional) If set to `true`, the broker requests a client certificate but doesn't require it.
*   `needClientAuth`: (Optional) If set to `true`, the broker requires a client certificate and will reject connections without one (mutual TLS).

On OpenShift, these keystore and truststore files, along with their passwords, are securely managed using OpenShift `Secret` objects. The AMQ Broker Operator then projects these secrets into the broker's pods as files, making them accessible to the broker process.

== Hands-on Lab: Configuring SSL/TLS for an AMQ Broker Acceptor

In this lab, you will configure an AMQ Broker acceptor to use SSL/TLS for secure client connections. For simplicity in a lab environment, we will generate a self-signed certificate and store it in an OpenShift Secret. In a production environment, you would typically obtain certificates from a trusted Certificate Authority (CA).

=== Prerequisites

*   An OpenShift cluster with `oc` CLI configured and logged in.
*   A project (namespace) created for your AMQ Broker deployment.
*   The Red Hat AMQ Broker Operator installed in your OpenShift cluster.
*   A basic AMQ Broker instance deployed and running in your project (e.g., using a minimal `ActiveMQArtemis` Custom Resource).
*   `openssl` command-line tool installed on your local machine.

=== Lab Steps

We will perform the following steps:

1.  Generate a self-signed server certificate and private key.
2.  Create an OpenShift Secret to store the certificate and key.
3.  Modify the `ActiveMQArtemis` Custom Resource to enable SSL/TLS on an existing acceptor.
4.  Verify the SSL/TLS configuration by connecting with a simple client (conceptual or using `openssl s_client`).

==== Step 1: Generate a Self-Signed Certificate and Key

First, let's create a directory to store our certificate files and generate a self-signed certificate and private key.

.Create a directory for certificates:
```bash
mkdir -p amq-ssl-certs
cd amq-ssl-certs
```

.Generate a private key:
```bash
openssl genrsa -out broker.key 2048
```
This command generates a 2048-bit RSA private key named `broker.key`.

.Generate a Certificate Signing Request (CSR):
```bash
openssl req -new -key broker.key -out broker.csr -subj "/C=US/ST=NC/L=Raleigh/O=Red Hat/OU=AMQ/CN=amq-broker-service.your-project.svc"
```
*   Replace `your-project` with the actual name of your OpenShift project where AMQ Broker is deployed.
*   The `CN` (Common Name) should match the service name of your AMQ Broker deployment, followed by the namespace and `.svc`. You can find your broker's service name using `oc get svc -l app.kubernetes.io/name=activemq-artemis`. For a default deployment, it might be something like `amq-broker-ss-0-svc.your-project.svc`. The full form is `_service-name_._namespace_.svc`.

.Self-sign the certificate:
```bash
openssl x509 -req -days 365 -in broker.csr -signkey broker.key -out broker.crt
```
This creates a self-signed certificate `broker.crt` valid for 365 days.

You should now have `broker.key` (private key) and `broker.crt` (certificate) in your `amq-ssl-certs` directory.

==== Step 2: Create an OpenShift Secret for the Certificate

AMQ Broker expects the certificate and key to be provided in a standard Java Keystore format (PKCS#12 or JKS). While the Operator can convert a plain PEM key/cert pair into a Java keystore automatically, it's good practice to understand the underlying mechanism. For simplicity, we will create an OpenShift `Secret` that the Operator can consume.

The AMQ Broker Operator expects the private key and certificate chain to be provided as base64-encoded values within a Secret. Specifically, it looks for keys like `tls.crt` and `tls.key` within a `kubernetes.io/tls` type Secret, or you can specify custom keys in the `ActiveMQArtemis` CR.

.Create the OpenShift Secret:
```bash
oc create secret tls amq-broker-tls --cert=broker.crt --key=broker.key -n your-project
```
Replace `your-project` with your actual OpenShift project name.

This command creates a Secret named `amq-broker-tls` of type `kubernetes.io/tls`. The Operator will automatically detect this format and project the certificate and key into the broker pod as a Java Keystore.

.Verify the Secret:
```bash
oc get secret amq-broker-tls -o yaml -n your-project
```
You should see the `tls.crt` and `tls.key` fields base64-encoded.

==== Step 3: Modify the `ActiveMQArtemis` Custom Resource

Now, we will modify your existing `ActiveMQArtemis` CR to enable SSL/TLS on an acceptor, referencing the `amq-broker-tls` secret.

.Get your existing `ActiveMQArtemis` CR:
```bash
oc get activemqartemis amq-broker-ss -o yaml -n your-project > amq-broker-cr.yaml
```
*   Replace `amq-broker-ss` with the name of your `ActiveMQArtemis` instance (if different).
*   Replace `your-project` with your actual OpenShift project name.

.Edit `amq-broker-cr.yaml` to add SSL/TLS configuration to an acceptor.

Locate the `spec.acceptors` section. You can either modify an existing acceptor or add a new one. For this lab, let's add a new SSL-enabled acceptor.

Find the `acceptors` list and add a new entry or modify an existing one. For example, to add an AMQP-based SSL acceptor:

```yaml
# ... (rest of your ActiveMQArtemis CR)
spec:
  # ...
  acceptors:
    # Existing acceptors...
    - name: my-ssl-acceptor
      port: 5671 # Standard AMQP TLS port
      protocols: AMQP
      sslEnabled: true
      sslSecret:
        secretName: amq-broker-tls
        # The Operator automatically handles deriving the keystore password
        # from the Secret content for kubernetes.io/tls type secrets.
        # If using a custom secret type, you might need to specify keyStorePassword
        # secretKeyRef: { name: "my-custom-keystore-password-secret", key: "password" }
      # Optional: Restrict protocols to only modern TLS versions
      sslEnabledProtocols: TLSv1.2,TLSv1.3
  # ...
```

.Apply the updated CR:
```bash
oc apply -f amq-broker-cr.yaml -n your-project
```
The AMQ Broker Operator will detect the change, reconcile the broker deployment, and potentially restart the broker pod(s) to apply the new configuration. Monitor the pod status until it's running again.

.Check the broker logs for confirmation:
```bash
oc logs -f $(oc get pod -l app.kubernetes.io/name=activemq-artemis -o jsonpath='{.items[0].metadata.name}' -n your-project) -n your-project | grep "AMQP"
```
You should see log entries indicating that the `my-ssl-acceptor` is listening on port `5671` with SSL/TLS enabled.

==== Step 4: Verify SSL/TLS Configuration

You can verify the SSL/TLS configuration using `openssl s_client` from your local machine or by attempting to connect with an AMQP client configured for SSL/TLS.

.Expose the SSL acceptor via an OpenShift Route or Service:

If you are trying to access from outside the cluster, you'll need to expose the new acceptor's port. Assuming your `my-ssl-acceptor` is on port `5671`, and your broker service is `amq-broker-ss-0-svc`:

```bash
oc expose service amq-broker-ss-0-svc --name=amq-broker-ssl-route --port=5671 --target-port=5671 -n your-project --hostname=ssl-amq.apps.$(oc get ingresscontroller default -n openshift-ingress-operator -o jsonpath='{.status.domain}')
```
Adjust the hostname as needed for your OpenShift cluster's ingress domain.
Get the route's hostname:
```bash
oc get route amq-broker-ssl-route -o jsonpath='{.status.ingress[0].host}' -n your-project
```
Let's assume the route hostname is `ssl-amq.apps.your-cluster-domain.com`.

.Test connection using `openssl s_client`:
```bash
openssl s_client -connect ssl-amq.apps.your-cluster-domain.com:443 -servername ssl-amq.apps.your-cluster-domain.com -showcerts
```
*   Replace `ssl-amq.apps.your-cluster-domain.com` with the actual hostname of your OpenShift Route.
*   Note: OpenShift Routes typically terminate TLS at the router level on port 443, and then forward plain HTTP/TCP to the backend service. If your Route is *passthrough*, then `openssl s_client` will connect directly to the broker's TLS endpoint. If it's *re-encrypt* or *edge*, the `s_client` command above should work, as the router presents its own certificate. For direct testing of the broker's certificate via a passthrough route or internal service access:

If using a passthrough route or if you are on the OpenShift cluster (e.g., in another pod) and connecting directly to the internal service:
```bash
# Get the broker's cluster IP and port
BROKER_IP=$(oc get svc amq-broker-ss-0-svc -n your-project -o jsonpath='{.spec.clusterIP}')
BROKER_PORT=5671

# Connect using openssl s_client
echo -n | openssl s_client -connect $BROKER_IP:$BROKER_PORT -showcerts
```
You should see a successful SSL/TLS handshake, details about the broker's certificate (including the self-signed certificate information), and potentially a prompt indicating a successful connection. Look for output like `Verification: OK` or `Verify return code: 0 (ok)`.

This confirms that your AMQ Broker acceptor is successfully configured for SSL/TLS, and clients can now establish secure, encrypted connections.

==== Troubleshooting Tips

*   **Certificate Subject Name Mismatch:** Ensure the Common Name (CN) in your broker's certificate matches the hostname clients use to connect (e.g., service name within OpenShift, or route hostname externally).
*   **Secret Not Found/Incorrect Format:** Double-check the `secretName` in your `ActiveMQArtemis` CR and ensure the Secret exists and contains the correct `tls.crt` and `tls.key` data.
*   **Port Conflicts:** Ensure the SSL-enabled acceptor uses a unique port and that the OpenShift service and route configurations correctly target this port.
*   **Firewall/Network Policies:** Verify that OpenShift Network Policies are not blocking traffic to the SSL-enabled port.
*   **Broker Logs:** Always check the AMQ Broker pod logs for specific error messages related to SSL/TLS initialization. These logs are often the quickest way to diagnose configuration issues.

This lab has demonstrated how to establish basic SSL/TLS encryption for client connections. For production environments, consider using certificates signed by a trusted CA, implementing mutual TLS (client certificate authentication), and properly managing certificate rotation.