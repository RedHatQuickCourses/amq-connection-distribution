#  Integrating with OpenShift authentication mechanisms

[[integrating-with-openshift-authentication]]
= Integrating with OpenShift Authentication Mechanisms

This module explores how Red Hat AMQ Broker, when deployed on OpenShift, can integrate with OpenShift's robust authentication and authorization infrastructure. While AMQ Broker has its own security mechanisms (such as JAAS and LDAP), leveraging OpenShift's identity providers can streamline security management for applications running within the platform, reducing credential sprawl and enhancing overall platform security.

[[openshift-identity-overview]]
== OpenShift Identity and Authentication Overview

OpenShift Container Platform provides a sophisticated identity management system that applications and users can leverage for secure access. Key components include:

*   *Service Accounts:* These are non-human accounts designed for processes running in pods. Each pod is automatically assigned a Service Account, and applications within the pod use the associated Service Account token to authenticate to the Kubernetes API and potentially other internal services. Service Accounts are fundamental for establishing identity and authorization for application-to-application communication within OpenShift.
*   *OAuth/OpenID Connect (OIDC) Provider:* OpenShift acts as an OAuth 2.0 and OpenID Connect provider. Users authenticate against various configured identity sources (e.g., HTPasswd, LDAP, GitHub, Google, Red Hat SSO/Keycloak) to obtain OAuth tokens. These tokens grant the authenticated user access to OpenShift API resources based on their assigned Role-Based Access Control (RBAC) roles.

[[integration-strategies]]
== AMQ Broker Integration Strategies

Integrating AMQ Broker directly with OpenShift's core authentication mechanisms for client connections requires careful consideration, as the broker's native security realms (like JAAS file or LDAP) do not inherently understand OpenShift's specific token formats (like Service Account tokens or OAuth tokens) out-of-the-box. However, several strategies allow for leveraging OpenShift's security context for robust authentication.

[[service-account-mtls]]
=== 1. Service Account-based Authentication via Mutual TLS (mTLS)

This is a robust and widely recommended method for authenticating client applications running *within* OpenShift when they connect to AMQ Broker.

.Technical Explanation
OpenShift, particularly through its internal certificate authority mechanisms or integration with solutions like Cert-Manager, can issue X.509 client certificates to Service Accounts. By configuring AMQ Broker for mutual TLS, where both the client and server present and validate each other's certificates, the broker can verify the client's identity based on an OpenShift-issued certificate.

*   *Client Identity:* When a pod is deployed and associated with a Service Account, OpenShift can project a client certificate and its corresponding private key into the pod's filesystem. This certificate is typically issued by an OpenShift internal CA and contains identity information specific to that Service Account (e.g., the Service Account's name and namespace embedded in the certificate's Subject Alternative Name or Common Name).
*   *Broker Configuration:* The AMQ Broker is configured to enable SSL/TLS on its network acceptors and to *require* client authentication (`needClientAuth: true`). Crucially, the broker's trust store must contain the public certificate of the OpenShift internal CA that issued these client certificates. Upon receiving a client certificate, the broker validates its authenticity against its trust store. The broker can then use the certificate's Subject (e.g., Common Name) or SAN entries to identify the connecting Service Account. This identity can then be mapped to specific roles or permissions within the broker's authorization mechanism (e.g., using a custom JAAS `X509LoginModule` or by configuring `security-roles` based on expected certificate attributes).

This approach centralizes certificate lifecycle management within OpenShift and provides strong cryptographic identity for internal clients, often considered an industry best practice for service-to-service authentication.

[[custom-jaas-module]]
=== 2. Custom JAAS Login Module for OpenShift OAuth Tokens

.Technical Explanation
For more advanced scenarios where human users (or applications acting on behalf of users) authenticate with OpenShift's OAuth server and obtain an OAuth token, a custom Java Authentication and Authorization Service (JAAS) login module can be developed for AMQ Broker.

*   *Token Reception:* The custom JAAS module would be configured on the AMQ Broker to receive the OpenShift OAuth token (e.g., passed as a password or a custom header) from the client.
*   *Token Validation:* This module would then need to validate the authenticity and validity of the OpenShift OAuth token. This typically involves:
    ** *Introspection:* Making an introspection call to OpenShift's OAuth server (or its dedicated introspection endpoint) to verify the token's validity, expiry, and claims.
    ** *Local Validation (for JWTs):* If the OpenShift token is a JSON Web Token (JWT), the module could validate its signature against OpenShift's public keys and verify its claims (issuer, audience, expiry) locally.
*   *Identity Mapping:* Upon successful validation, the module would extract relevant user information (e.g., username, group memberships) from the token's claims and map it to AMQ Broker roles and permissions for authorization.

This method offers true integration with OpenShift's user identity, allowing AMQ Broker to directly consume identities established through OpenShift's OAuth flow. However, it requires custom Java development, deployment, and ongoing maintenance of the JAAS module.

[[sidecar-proxy]]
=== 3. Sidecar Proxy / API Gateway Authentication

.Technical Explanation
An alternative, less intrusive approach to integrating with OpenShift authentication is to deploy an authentication proxy or API Gateway. This component can be deployed as a sidecar container alongside the AMQ Broker pod or as a dedicated service acting as a front-end to the broker.

*   *Proxy's Role:* The proxy intercepts client connections destined for the AMQ Broker. It is configured to handle the validation of OpenShift OAuth tokens (for users) or Service Account tokens (for applications) from incoming clients. The proxy acts as the *policy enforcement point*.
*   *Broker Communication:* Once the proxy successfully authenticates and authorizes a client using OpenShift's mechanisms, it then establishes a connection to the AMQ Broker itself. This connection from the proxy to the broker can use its own pre-configured credentials (e.g., a shared secret, client certificate, or a dedicated broker user) that the broker already understands. The proxy effectively translates OpenShift-based identities into AMQ Broker-understandable credentials.

This strategy decouples the broker's security configuration from OpenShift's specific identity providers, allowing for more flexible and pluggable authentication mechanisms without modifying the core broker directly. It also centralizes authentication logic in a reusable component.

[[openshift-rbac-broker-management]]
=== 4. OpenShift RBAC for Broker Management

.Technical Explanation
While not directly related to client messaging authentication, it is crucial to understand that *managing* the AMQ Broker instances on OpenShift is inherently integrated with OpenShift's authentication and authorization (Role-Based Access Control - RBAC).

*   *Operator Interaction:* Users or Service Accounts that interact with the `AMQ Broker Operator` (e.g., by creating, updating, or deleting `ActiveMQArtemis` Custom Resources, or managing the broker's pods and services) must first be authenticated by OpenShift. Their access is then authorized via OpenShift RBAC roles assigned to them (e.g., `edit`, `admin` roles within a project, or custom roles targeting specific CRDs).
*   *Control Plane Security:* This ensures that only authorized personnel or automation tools can control the lifecycle, scaling, and configuration of AMQ Broker instances running on the platform, leveraging OpenShift's centralized identity system for critical operational tasks.

[[hands-on-lab-integrating-with-openshift-authentication]]
== Hands-on Lab: Configuring Service Account-based mTLS for AMQ Broker (Conceptual)

Integrating OpenShift's certificate authority with AMQ Broker for mTLS involves several steps, including configuring the OpenShift cluster to issue workload certificates (either natively or via tools like Cert-Manager) and then configuring the broker to trust those certificates. Due to the potential complexity of setting up a complete OpenShift internal CA and certificate issuance policy, this lab will outline the *conceptual steps* rather than providing a fully runnable script. The goal is to highlight the integration points and the thought process behind securing AMQ Broker clients with OpenShift Service Account identities using mTLS.

.Objective
Configure AMQ Broker to use mTLS with client certificates issued by OpenShift for Service Accounts, allowing AMQ Broker to authenticate clients based on their OpenShift identity.

.Prerequisites
*   An OpenShift cluster with administrative access (e.g., `kubeadmin` or a user with cluster-admin roles).
*   `oc` CLI tool configured and authenticated.
*   An AMQ Broker instance deployed via the Operator (e.g., in a dedicated `amq-broker` project).
*   Understanding of OpenShift Service Accounts and TLS/PKI concepts.
*   Your OpenShift cluster should be configured to project service account tokens and/or certificates into pods. This is generally enabled by default in modern OpenShift versions but might require specific configuration for client certificates.

.Steps (Conceptual)

. Create a Project and Service Account for the Client Application
****
First, create a new OpenShift project (namespace) for your client application and a dedicated Service Account within it. This Service Account will be the identity for your client connecting to the AMQ Broker.

[source,bash]
----
# Create a new project for the client application
oc new-project amq-client-app

# Create a Service Account for the AMQ client
oc create serviceaccount my-broker-client -n amq-client-app
----
****

. (Optional/Verification) Understand Service Account Token Projection
****
In modern OpenShift/Kubernetes, service account tokens (and sometimes derived certificates) are projected into pods. Verify the `openshift-apiserver` configuration for Service Account signing, or rely on default behavior. When a pod uses a Service Account, a token and potentially a client certificate (if workload identity is configured) are automatically mounted.

[source,bash]
----
# Example: Deploy a temporary pod to inspect the projected Service Account files
cat << EOF | oc apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: sa-inspector
  namespace: amq-client-app
spec:
  serviceAccountName: my-broker-client
  containers:
  - name: inspector
    image: registry.access.redhat.com/ubi8/ubi-minimal:latest
    command: ["sh", "-c", "ls -l /var/run/secrets/kubernetes.io/serviceaccount; sleep 3600"]
    securityContext:
      runAsNonRoot: true
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      seccompProfile:
        type: RuntimeDefault
  restartPolicy: Never
EOF

# Once the pod is running, inspect its logs
oc logs -f sa-inspector -n amq-client-app
# Look for files like 'ca.crt', 'token', and potentially 'tls.crt'/'tls.key' if client certificates are projected.
# The `ca.crt` found here is the OpenShift service account signer CA bundle.
----
*Explanation:* The `ca.crt` inside `/var/run/secrets/kubernetes.io/serviceaccount` is typically the bundle of trusted CAs, including the OpenShift internal CA that signs service account tokens and potentially certificates. This is the CA you'll need the broker to trust.
****

. Obtain the OpenShift Internal CA Certificate
****
The AMQ Broker needs to trust the CA that issues the client certificates for your Service Accounts. This is typically an internal OpenShift CA. You can extract the relevant CA bundle from your cluster configuration.

[source,bash]
----
# Get the OpenShift Service Account signer CA bundle
# This CA bundle is used to sign various internal workload certificates.
oc get cm -n openshift-config-managed cvo-trusted-cas -o jsonpath='{.data."ca-bundle\.crt"}' > openshift-internal-ca-bundle.crt

# Create a Secret in your AMQ Broker's namespace from this CA bundle.
# Assuming your broker is in the 'amq-broker' namespace.
oc create secret generic openshift-internal-ca-bundle-secret \
  --from-file=ca.crt=openshift-internal-ca-bundle.crt \
  -n amq-broker
----
*Explanation:* This secret will hold the public certificate of the CA that your broker needs to trust to validate client certificates presented by Service Accounts.

****

. Configure AMQ Broker for Mutual TLS
****
Update your `ActiveMQArtemis` Custom Resource (CR) to enable mTLS on its acceptor, ensuring it trusts the OpenShift internal CA.

[source,yaml]
----
# Example ActiveMQArtemis CR snippet (apply this to your existing broker CR)
apiVersion: broker.amq.io/v1beta1
kind: ActiveMQArtemis
metadata:
  name: my-broker # Replace with your broker instance name
  namespace: amq-broker
spec:
  acceptors:
    - name: my-secure-acceptor # Choose an appropriate name for your acceptor
      protocols: AMQP,CORE,MQTT,OPENWIRE,STOMP
      sslEnabled: true
      # Assuming you have a secret with your broker's server certificate and key
      # This secret typically contains 'broker.crt', 'broker.key', 'ca.crt' (server's CA)
      sslSecret: broker-server-ssl-secret # Replace with your actual broker's SSL secret
      # IMPORTANT: Enable needClientAuth to enforce mutual TLS
      needClientAuth: true
      # Reference the secret containing the OpenShift internal CA certificate(s)
      trustStore:
        secretName: openshift-internal-ca-bundle-secret # The secret created in step 3
        password: changeit # This password is for the JKS truststore if applicable.
                           # If your secret just contains a PEM file, this might not be strictly needed or is a placeholder.
        # Alternatively, for simple PEM, you might reference a ConfigMap with the PEM file:
        # configMapName: openshift-internal-ca-bundle-cm
        # file: ca.crt
      # To specify which JAAS realm to use for X.509 client authentication
      securityRealm: X509ClientRealm # This realm needs to be defined in broker.xml
  # ... other broker configurations ...
  brokerProperties: # Adding security realm configuration for X509
    - "broker.xml:
        <security-realms>
            <security-realm name=\"X509ClientRealm\">
                <properties key=\"jaas.config\" value=\"org.apache.activemq.artemis.spi.core.security.jaas.X509LoginModule required debug=true user.certs.cn.matches.role=true;\"/>
            </security-realm>
        </security-realms>"
  # Define security settings to authorize roles derived from certificate CNs
    - "broker.xml:
        <security-settings>
            <security-setting name=\"#\">
                <permission type=\"createDurableQueue\" roles=\"amq-admin\"/>
                <permission type=\"deleteDurableQueue\" roles=\"amq-admin\"/>
                <permission type=\"createNonDurableQueue\" roles=\"amq-admin, my-broker-client-role\"/>
                <permission type=\"deleteNonDurableQueue\" roles=\"amq-admin\"/>
                <permission type=\"send\" roles=\"amq-admin, my-broker-client-role\"/>
                <permission type=\"consume\" roles=\"amq-admin, my-broker-client-role\"/>
                <permission type=\"manage\" roles=\"amq-admin\"/>
            </security-setting>
        </security-settings>"
----

*Explanation:*
*   `sslEnabled: true`: Activates SSL/TLS for the specified acceptor.
*   `sslSecret`: Points to the Kubernetes Secret containing the AMQ Broker's server certificate and private key.
*   `needClientAuth: true`: This is critical. It forces clients to present a valid client certificate during the TLS handshake.
*   `trustStore`: Configured with the `openshift-internal-ca-bundle-secret` so the broker can validate client certificates signed by the OpenShift internal CA.
*   `securityRealm: X509ClientRealm`: Specifies that this acceptor should use a custom `X509LoginModule` for client authentication.
*   `brokerProperties` for `security-realms`: Defines the `X509ClientRealm` which uses `org.apache.activemq.artemis.spi.core.security.jaas.X509LoginModule`. The `user.certs.cn.matches.role=true` property is powerful here. If a client certificate's Common Name (CN) is, for example, `system:serviceaccount:amq-client-app:my-broker-client`, the `X509LoginModule` will attempt to map this CN to a role. You would then map `my-broker-client-role` to your specific permissions. (Note: The actual CN format for OpenShift Service Account certificates can vary, so you might need to adjust mapping logic).
*   `brokerProperties` for `security-settings`: Grants `send` and `consume` permissions to the `my-broker-client-role`, which will be associated with your `my-broker-client` Service Account.

Apply these changes to your `ActiveMQArtemis` CR using `oc apply -f <your-broker-cr.yaml>`. The Operator will reconcile the changes and restart the broker pods.
****

. Deploy and Configure the Client Application
****
Now, deploy your client application (e.g., a message producer/consumer) in the `amq-client-app` project. This application must be configured to use the `my-broker-client` Service Account and to load the projected client certificate and key for its AMQ connection.

[source,yaml]
----
# Example: A simple deployment that uses the Service Account
# and would typically load projected certificates for mTLS.
cat << EOF | oc apply -f -
apiVersion: apps.openshift.io/v1
kind: Deployment
metadata:
  name: amq-client-producer
  namespace: amq-client-app
spec:
  selector:
    matchLabels:
      app: amq-client-producer
  replicas: 1
  template:
    metadata:
      labels:
        app: amq-client-producer
    spec:
      serviceAccountName: my-broker-client # Assign the client Service Account
      containers:
      - name: producer
        # Replace with your actual AMQ client image (e.g., a Java client, Python client)
        image: registry.access.redhat.com/amq7/amq-broker-client-java-rhel8:1.1.0-2 # Example client image
        env:
        - name: BROKER_HOST
          value: my-broker-svc.amq-broker.svc # Internal OpenShift service name
        - name: BROKER_PORT
          value: "5671" # AMQPS port
        - name: QUEUE_NAME
          value: my-secure-queue
        # Volume mount for projected Service Account tokens and certificates
        volumeMounts:
        - name: sa-certs
          mountPath: /var/run/secrets/kubernetes.io/serviceaccount
          readOnly: true
        command: ["/bin/sh", "-c", "echo 'Starting AMQ client producer with mTLS...' && \
                                   # This is a conceptual client execution command.
                                   # Your client needs to be configured to load the CA, client cert, and key
                                   # from /var/run/secrets/kubernetes.io/serviceaccount/
                                   # For Java clients, this might involve setting system properties for keystore/truststore.
                                   # Example for Python/CLI tools:
                                   # python client.py --broker $BROKER_HOST:$BROKER_PORT \
                                   #                 --queue $QUEUE_NAME \
                                   #                 --ca-cert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
                                   #                 --client-cert /var/run/secrets/kubernetes.io/serviceaccount/tls.crt \
                                   #                 --client-key /var/run/secrets/kubernetes.io/serviceaccount/tls.key \
                                   # This will likely require custom scripting based on how client certificates are actually projected
                                   # and how your specific AMQ client library is configured for mTLS.
                                   sleep 3600"] # Keep pod running for inspection
      volumes:
      - name: sa-certs
        projected:
          sources:
          - serviceAccountToken:
              path: token
              expirationSeconds: 3600
              audience: kubernetes
          # If your OpenShift config projects client certificates here, include them:
          # - secret: # Example: If a dedicated secret is created for the SA certificate
          #     name: my-broker-client-sa-cert
          #     items:
          #       - key: tls.crt
          #         path: tls.crt
          #       - key: tls.key
          #         path: tls.key
          # If OpenShift directly projects workload certificates based on SA, it would appear here.
          # For demonstration, assume ca.crt, tls.crt, tls.key are available through these mounts.
EOF
----

*Explanation:*
*   The `serviceAccountName: my-broker-client` ensures the pod runs with the specified identity.
*   The `volumeMounts` and `volumes` configure the projection of the Service Account token and associated files (including the CA certificate and, ideally, a client certificate/key pair for the Service Account) into the pod.
*   Your client application *inside* the pod needs to be specifically configured to load the `tls.crt` (client certificate), `tls.key` (client private key), and `ca.crt` (broker's trusted CA, which includes the OpenShift internal CA) for its AMQP/MQTT/OpenWire/STOMP connection. The exact method depends on the client library and language.

. Test Client Connectivity
****
After deploying the client application, monitor its logs to confirm successful connection and message exchange. The AMQ Broker's logs should also show successful authentication via the X.509 login module.

[source,bash]
----
# Check client pod status
oc get pod -n amq-client-app -l app=amq-client-producer

# View client logs to confirm connection (look for "Connected", "Messages sent/received")
oc logs -f deployment/amq-client-producer -n amq-client-app

# Optional: Inspect broker logs for authentication events
# Replace 'my-broker-ss-0' with the actual broker pod name
oc logs -f my-broker-ss-0 -n amq-broker | grep "X509LoginModule"
oc logs -f my-broker-ss-0 -n amq-broker | grep "Authentication successful"
----

*Troubleshooting:*
*   If the client fails to connect, check the broker logs for TLS handshake errors (e.g., "client did not present certificate", "certificate validation failed").
*   Ensure the `openshift-internal-ca-bundle-secret` correctly contains the CA that signed your client certificate.
*   Verify the `needClientAuth: true` and `securityRealm: X509ClientRealm` are correctly applied to the broker's acceptor.
*   Confirm the client application is correctly loading and presenting its client certificate and private key.

This conceptual lab demonstrates how AMQ Broker can be configured to leverage OpenShift Service Accounts as a form of client identity through mutual TLS, providing strong cryptographic authentication for internal applications.