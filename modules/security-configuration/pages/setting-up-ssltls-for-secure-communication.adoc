#  Setting up SSL/TLS for secure communication

= Setting up SSL/TLS for Secure Communication

:page-toclevels: 3

Securing communication channels is paramount for any messaging system, especially when sensitive data is being exchanged or when brokers are exposed over untrusted networks. Red Hat AMQ Broker, when deployed on OpenShift, leverages industry-standard SSL/TLS (Secure Sockets Layer/Transport Layer Security) protocols to encrypt data in transit and authenticate communicating parties.

== Understanding SSL/TLS in AMQ Broker Context

SSL/TLS provides two primary security features for network communication:

*   **Encryption**: It encrypts the data exchanged between clients and the broker, or between brokers themselves, preventing eavesdropping and ensuring confidentiality.
*   **Authentication**: It allows clients to verify the identity of the broker (server authentication), and optionally, allows the broker to verify the identity of the client (mutual TLS or client authentication), preventing impersonation.

In the context of AMQ Broker, SSL/TLS is typically configured for:

*   **Client-to-Broker Communication**: Ensuring secure connections for messaging clients using various protocols (e.g., AMQP, MQTT, OpenWire, STOMP) connecting to the broker's network acceptors.
*   **Inter-Broker Communication**: Securing communication between brokers in a cluster (e.g., for high availability, message federation, or store-and-forward links).
*   **Management Console Access**: Protecting access to the Hawtio console for broker management (though this often relies on OpenShift's default routing security).

=== Core Concepts: Certificates, Keystores, and Truststores

To enable SSL/TLS, the following components are essential:

*   **Certificates**: Digital documents that bind a public key to an entity (like the AMQ Broker). They are issued by a Certificate Authority (CA) for production use or can be self-signed for development and testing environments.
    *   **Public Key Certificate**: Contains the public key and identity information of the owner. This is shared openly.
    *   **Private Key**: A secret key that mathematically corresponds to the public key. It is used to decrypt data that was encrypted with the public key or to sign digital signatures. The private key must be kept strictly confidential.
*   **Keystore**: A secure repository that stores an entity's own private keys and their corresponding public key certificates. The AMQ Broker uses its keystore to present its certificate to connecting clients and to decrypt incoming SSL/TLS traffic. Keystores are typically secured with a password.
*   **Truststore**: A secure repository that stores public key certificates from Certificate Authorities (CAs) that an entity trusts, or directly stores trusted peer entity certificates. The AMQ Broker uses its truststore (if configured) to verify the certificates presented by connecting clients (for mutual TLS) or by other brokers. Similarly, clients use a truststore to verify the broker's certificate. Truststores are also typically secured with a password.

image::amq-broker-ssl-tls-flow.png[SSL/TLS Communication Flow with AMQ Broker, 600, align=center]
_Figure: Simplified SSL/TLS Communication Flow with AMQ Broker_

.Detailed Flow of an SSL/TLS Handshake
1.  **Client Hello**: The client initiates the connection and sends a "Client Hello" message, specifying the TLS versions it supports, preferred cipher suites, and a random byte string.
2.  **Server Hello**: The broker (server) responds with a "Server Hello," choosing the highest common TLS version and cipher suite, its own random byte string, and its digital certificate.
3.  **Certificate Verification**: The client validates the broker's certificate against its own truststore. If the certificate is valid and trusted, the client trusts the broker's identity.
4.  **Key Exchange**: The client generates a pre-master secret, encrypts it using the broker's public key (obtained from the certificate), and sends it to the broker.
5.  **Decryption**: The broker decrypts the pre-master secret using its private key.
6.  **Symmetric Key Generation**: Both the client and the broker independently generate a shared symmetric session key using the pre-master secret and the random strings exchanged earlier.
7.  **Encrypted Communication**: All subsequent application data communication between the client and broker is encrypted using this shared symmetric session key, ensuring confidentiality.
8.  **Client Authentication (Optional - Mutual TLS)**: If `requireClientAuth` is enabled on the broker, the broker will request a certificate from the client, and the client will present it. The broker then validates the client's certificate against its own truststore to authenticate the client.

=== Integrating with OpenShift Secrets

On OpenShift, sensitive data like keystores and truststores (which contain private keys and certificates) should be managed as xref:openshift-introduction.adoc#_openshift_secrets[OpenShift Secrets]. The AMQ Broker Operator can then mount these secrets into the broker pods, making the keystore and truststore files available for the broker process.

This approach offers several benefits:

*   **Security**: Secrets are stored encrypted at rest in `etcd` and are not exposed in plain text within `Pod` definitions or `Deployment` configurations. They can also be restricted by RBAC.
*   **Automation**: The Operator automatically handles injecting the secrets as volumes into the broker containers and configuring the broker's startup script to use them.
*   **Centralized Management**: Kubernetes provides robust tools for managing secrets across the cluster, including updating and rotating them.

== Configuring SSL/TLS for AMQ Broker on OpenShift

To enable SSL/TLS for an AMQ Broker instance on OpenShift, you typically need to perform the following high-level steps:

1.  **Obtain/Generate Certificates**: Decide whether to use certificates issued by a trusted Certificate Authority (CA) (recommended for production) or self-signed certificates (suitable for development/testing).
2.  **Create Keystore and Truststore**: Package the broker's private key and public certificate into a keystore file. If mutual TLS is required, also create a truststore file containing trusted CA certificates (or client certificates). These are typically Java KeyStore (JKS) or PKCS12 formats.
3.  **Create OpenShift Secrets**: Store the keystore and truststore files, along with their passwords, as Kubernetes Secrets in the namespace where your broker is deployed.
4.  **Update the `Broker` Custom Resource (CR)**: Configure the AMQ Broker's network acceptors (for incoming client connections) and/or connectors (for outgoing inter-broker connections) to use the specified secrets for SSL/TLS.

=== Detailed Steps for `Broker` CR Configuration

Within the `Broker` Custom Resource, SSL/TLS configuration is primarily done within the `spec.acceptors` and `spec.connectors` sections. Each acceptor or connector can have its own SSL/TLS configuration.

[source,yaml]
----
apiVersion: broker.amq.io/v1beta1
kind: Broker
metadata:
  name: my-broker-ssl
spec:
  # ... other broker configurations ...
  acceptors:
    - name: amqp-ssl
      protocols:
        - AMQP
      port: 5671 # Standard AMQP TLS port
      sslEnabled: true
      sslSecret: my-broker-keystore-secret # Name of the Secret containing the keystore
      # Optional for mutual TLS / client authentication:
      sslTrustStoreSecret: my-broker-truststore-secret # Name of the Secret containing the truststore
      sslTrustStorePassword: password # Password for the truststore (if not in secret)
      requireClientAuth: false # Set to true to require clients to authenticate with a certificate
      # Optional: Advanced SSL/TLS settings
      sslEnabledCipherSuites:
        - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
        - TLS_AES_256_GCM_SHA384
      sslEnabledProtocols:
        - TLSv1.2
        - TLSv1.3
      # ... other acceptor properties ...
----

Key fields for SSL/TLS configuration in an acceptor (similar fields apply to connectors):

*   `sslEnabled`: A boolean flag. Set to `true` to enable SSL/TLS for this specific acceptor or connector.
*   `sslSecret`: The name of the Kubernetes `Secret` that contains the broker's keystore file (e.g., `broker.ks` or `broker.p12`) and its corresponding password. The Operator expects this secret to contain keys such as `broker.ks` (or `broker.p12`) and `broker.ks.password` (or `broker.p12.password`).
*   `sslTrustStoreSecret`: (Optional) The name of the Kubernetes `Secret` that contains the broker's truststore file (e.g., `broker.ts` or `broker.p12`) and its password. This is required if `requireClientAuth` is `true` or if the broker needs to trust certificates from other brokers or external services.
*   `sslTrustStorePassword`: (Optional) The password for the truststore. If provided here, the secret *should not* contain a `broker.ts.password` key. It's generally recommended to store the password within the secret itself for consistency.
*   `requireClientAuth`: A boolean flag. Set to `true` to enable mutual TLS, meaning the broker will require connecting clients to present a valid certificate from a trusted CA (as defined in the broker's `sslTrustStoreSecret`).
*   `sslEnabledCipherSuites`: (Optional) A comma-separated list of permitted cipher suites. If omitted, the broker uses a default set of secure ciphers. It's crucial to select strong, modern cipher suites.
*   `sslEnabledProtocols`: (Optional) A comma-separated list of permitted TLS protocols (e.g., `TLSv1.2,TLSv1.3`). If omitted, the broker uses a default set of secure protocols.

[[lab-security-ssl]]
== Hands-on Lab: Implementing SSL/TLS for AMQ Broker

In this lab, you will configure an AMQ Broker instance on OpenShift to use self-signed SSL/TLS certificates for secure client communication via an AMQP acceptor.

=== Prerequisites

*   Access to an OpenShift cluster with the Red Hat AMQ Broker Operator installed.
*   `oc` command-line tool configured to access your OpenShift cluster.
*   An existing project. If not, create one: `oc new-project amq-broker-project`.
*   Ensure OpenSSL is installed on your local machine.

=== Lab Steps

==== Step 1: Deploy a Basic AMQ Broker Instance

If you don't already have a broker deployed, create a simple one. We'll name it `my-broker-ssl-lab`.

1.  **Deploy the Broker:**
    [source,bash]
    ----
    oc project amq-broker-project # Ensure you are in the correct project
    cat <<EOF | oc apply -f -
    apiVersion: broker.amq.io/v1beta1
    kind: Broker
    metadata:
      name: my-broker-ssl-lab
    spec:
      deploymentPlan:
        size: 1
        image: registry.redhat.io/amq7/amq-broker-rhel8:7.10
      acceptors:
        - name: amqp
          port: 5672
          protocols:
            - AMQP
    EOF
    ----
    Wait for the broker pod to be in a `Running` state:
    [source,bash]
    ----
    oc get pod -l app.kubernetes.io/name=my-broker-ssl-lab -w
    ----

==== Step 2: Generate Self-Signed Certificates

We will use `openssl` to generate a private key and a self-signed certificate for the broker. For a production environment, you would typically obtain these from a trusted Certificate Authority.

1.  **Determine the Broker's Internal Service Hostname:**
    The `CN` (Common Name) in the certificate *must* match the hostname clients will use to connect. For internal OpenShift connections to a service, this is typically in the format `<service-name>.<project-name>.svc.cluster.local`.

    Find the service name created by the Operator for `my-broker-ssl-lab`:
    [source,bash]
    ----
    BROKER_SERVICE_NAME=$(oc get service -l broker.amq.io/v1beta1_Broker=my-broker-ssl-lab -o jsonpath='{.items[0].metadata.name}')
    PROJECT_NAME=$(oc project -q)
    BROKER_HOSTNAME="${BROKER_SERVICE_NAME}.${PROJECT_NAME}.svc.cluster.local"
    echo "Broker Hostname for Certificate: ${BROKER_HOSTNAME}"
    ----
    *Take note of the `BROKER_HOSTNAME` value, as you'll use it in the next step.*

2.  **Generate a Private Key and Certificate Signing Request (CSR):**
    [source,bash]
    ----
    openssl genrsa -out broker.key 2048
    # Use the BROKER_HOSTNAME obtained above for the CN
    openssl req -new -key broker.key -out broker.csr -subj "/CN=${BROKER_HOSTNAME}"
    ----

3.  **Self-Sign the Certificate:**
    [source,bash]
    ----
    openssl x509 -req -days 365 -in broker.csr -signkey broker.key -out broker.crt
    ----
    You should now have three files: `broker.key` (private key), `broker.csr` (certificate signing request), and `broker.crt` (public certificate).

==== Step 3: Create a Keystore (PKCS12 format)

The AMQ Broker uses Java's keystore formats. PKCS12 is a common and flexible format that can store both private keys and certificates.

1.  **Create a PKCS12 Keystore from the generated key and certificate:**
    [source,bash]
    ----
    # Use the BROKER_HOSTNAME for the alias name, replacing `<your-broker-hostname>` if you didn't set the variable.
    openssl pkcs12 -export -name "${BROKER_HOSTNAME}" -out broker.p12 -inkey broker.key -in broker.crt -password pass:changeit
    ----
    *   The password `changeit` is used for the keystore. **Remember this password**, as it will be stored in an OpenShift Secret and used by the broker.

==== Step 4: Create OpenShift Secret for the Keystore

The AMQ Broker Operator expects secrets for SSL/TLS to contain the keystore/truststore file and its password.

1.  **Create a Kubernetes Secret for the Keystore:**
    [source,bash]
    ----
    oc create secret generic my-broker-ssl-keystore \
      --from-file=broker.p12 \
      --from-literal=broker.p12.password=changeit
    ----
    *   This creates a secret named `my-broker-ssl-keystore` containing two data entries: `broker.p12` (your keystore file) and `broker.p12.password` (the password for the keystore).

    TIP: You can verify the secret contents (without exposing the actual password in plain text) using:
    [source,bash]
    ----
    oc get secret my-broker-ssl-keystore -o yaml
    ----

==== Step 5: Update the AMQ Broker Custom Resource

Now, modify your `Broker` CR (`my-broker-ssl-lab`) to enable SSL/TLS on a new acceptor, referencing the created secret.

1.  **Edit the `Broker` Custom Resource:**
    [source,bash]
    ----
    oc edit broker my-broker-ssl-lab
    ----

2.  **Locate the `acceptors` section** and add a new acceptor with SSL/TLS configuration. For this lab, let's add a new AMQP SSL acceptor on port `5671`.

    Add the following YAML block under `spec.acceptors:` (ensure proper indentation):
    [source,yaml]
    ----
      - name: amqp-ssl-secure
        port: 5671
        protocols:
          - AMQP
        sslEnabled: true
        sslSecret: my-broker-ssl-keystore # Reference the secret we created
        # No truststore or client auth for this basic setup
    ----

    Your `Broker` CR `spec.acceptors` section might look something like this after modification:
    [source,yaml]
    ----
    # ...
    spec:
      # ...
      acceptors:
        - name: amqp
          port: 5672
          protocols:
            - AMQP
        - name: amqp-ssl-secure # NEW SECURE ACCEPTOR
          port: 5671
          protocols:
            - AMQP
          sslEnabled: true
          sslSecret: my-broker-ssl-keystore
    # ...
    ----
    Save and close the editor. The Operator will detect the change and redeploy the broker pod(s) with the updated configuration.

3.  **Monitor the Broker Deployment:**
    [source,bash]
    ----
    oc get pod -l app.kubernetes.io/name=my-broker-ssl-lab -w
    ----
    Wait for the broker pod to restart and become `Running` again.

==== Step 6: Verify SSL/TLS Configuration (Optional)

You can verify that the broker is listening on the SSL port and that its certificate is being presented.

1.  **Check Broker Logs:**
    [source,bash]
    ----
    oc logs -l broker.amq.io/v1beta1_Broker=my-broker-ssl-lab
    ----
    Look for messages indicating the `amqp-ssl-secure` acceptor starting up with SSL/TLS enabled, for example:
    `INFO  [org.apache.activemq.artemis.core.server] AMQ221007: Server will accept connections from /0.0.0.0:5671 for SSL`

2.  **Port Forward and Test with `openssl s_client` (Advanced/Troubleshooting):**
    Get the broker pod name:
    [source,bash]
    ----
    BROKER_POD=$(oc get pod -l broker.amq.io/v1beta1_Broker=my-broker-ssl-lab -o jsonpath='{.items[0].metadata.name}')
    echo "Broker Pod: ${BROKER_POD}"
    ----
    Port forward the SSL port (5671) from the broker pod to your local machine:
    [source,bash]
    ----
    oc port-forward $BROKER_POD 5671:5671 &
    ----
    Now, use `openssl s_client` to connect and inspect the certificate:
    [source,bash]
    ----
    openssl s_client -connect localhost:5671 -showcerts
    ----
    In the output, look for the certificate details (e.g., `subject=/CN=<your-broker-hostname>`) to confirm that your self-signed certificate is being used. Press `Ctrl+C` to exit `openssl s_client` and then `fg` and `Ctrl+C` to kill the `oc port-forward` process.

3.  **Connect with an AMQP Client (Conceptual):**
    To truly test, you would configure an AMQP client (e.g., using Python's `pika` or Java's `qpid-jms`) to connect to `${BROKER_HOSTNAME}:5671` using SSL/TLS, trusting the `broker.crt` (or a client-side truststore containing it). This would involve client-side setup beyond the scope of this specific lab focused on broker configuration.

Congratulations! You have successfully configured AMQ Broker on OpenShift to use SSL/TLS for secure communication.

=== Cleanup (Optional)

To clean up the resources created in this lab:

[source,bash]
----
oc delete broker my-broker-ssl-lab
oc delete secret my-broker-ssl-keystore
rm broker.key broker.csr broker.crt broker.p12
----

== Troubleshooting Common SSL/TLS Issues

When encountering issues with SSL/TLS, checking both broker logs and client error messages is crucial.

*   **`javax.net.ssl.SSLHandshakeException` (Client-side)**: This is a general error indicating a problem during the TLS handshake.
    *   **"PKIX path building failed" / "unable to find valid certification path to requested target"**: This is a very common error indicating the client does not trust the broker's certificate.
        *   **Solution**: Ensure the client's truststore contains the CA certificate that signed the broker's certificate. If using a self-signed certificate (as in this lab), the client's truststore must directly include the `broker.crt` you generated.
    *   **"No appropriate protocol (protocol is disabled or cipher suites are inappropriate)"**: The client and broker could not agree on a common TLS protocol version or cipher suite.
        *   **Solution**: Check `sslEnabledProtocols` and `sslEnabledCipherSuites` on both the broker's `Broker` CR and the client's configuration to ensure compatibility.
*   **Incorrect Keystore/Truststore Password**: The broker logs will show errors related to loading the keystore/truststore if the password specified in the secret (`broker.p12.password`) or in `sslTrustStorePassword` is incorrect or doesn't match the password used during the keystore/truststore creation.
    *   **Solution**: Double-check the password used when creating `broker.p12` and ensure it's accurately stored in the OpenShift Secret.
*   **Certificate Common Name (CN) Mismatch**: If the `CN` in the broker's certificate does not match the hostname the client is using to connect, the client might reject the connection to prevent man-in-the-middle attacks.
    *   **Solution**: Ensure the `CN` used when generating the certificate precisely matches the hostname clients use (e.g., `service-name.project-name.svc.cluster.local` for internal services, or the Route's hostname for external access).
*   **Missing or Incorrect Secret**:
    *   **`sslSecret` / `sslTrustStoreSecret` names**: Ensure the secret names specified in the `Broker` CR (e.g., `my-broker-ssl-keystore`) exactly match the names of the Kubernetes Secrets you created.
    *   **Secret contents**: Verify that the secret contains the correct keys (e.g., `broker.p12` and `broker.p12.password`).
*   **Broker Not Restarted**: After updating the `Broker` CR, the AMQ Broker Operator needs to detect the change and redeploy the broker pod for the new SSL/TLS configuration to take effect.
    *   **Solution**: Monitor `oc get pod -l broker.amq.io/v1beta1_Broker=<broker-name>` to ensure the pod has restarted and is in a `Running` state.
*   **Firewall/Network Policies**: Even with correct SSL/TLS configuration, OpenShift Network Policies or external firewalls might be blocking traffic to the SSL port (e.g., 5671).
    *   **Solution**: Verify that network policies allow ingress traffic to the broker's SSL port from relevant sources.

By carefully following these steps and understanding the underlying concepts, you can effectively secure your AMQ Broker deployments on OpenShift using SSL/TLS.