#  Hands-on Lab: Implementing Security for AMQ Broker

= Hands-on Lab: Implementing Security for AMQ Broker
:navtitle: Lab: Security
:page-aliases: amq-on-openshift:labs/lab-security.adoc

In this lab, you will learn how to implement essential security measures for your Red Hat AMQ Broker deployment on OpenShift. We will cover user authentication, authorization using Access Control Lists (ACLs), and securing client-broker communication with SSL/TLS.

[IMPORTANT]
====
This lab assumes you have a basic understanding of OpenShift concepts and `oc` CLI commands. It also assumes you have an AMQ Broker instance named `my-broker` already deployed and running in your OpenShift project, as covered in previous sections like "Deploying AMQ Broker instances using the Operator".
====

== 1. Understanding AMQ Broker Security

Securing your messaging infrastructure is paramount to protect sensitive data, prevent unauthorized access, and ensure reliable communication. Red Hat AMQ Broker provides robust security features, which we will configure using the AMQ Broker Operator on OpenShift.

=== 1.1 Authentication

Authentication is the process of verifying the identity of a user or application attempting to connect to the broker. AMQ Broker supports various authentication mechanisms, including:

*   **JAAS (Java Authentication and Authorization Service):** A pluggable framework allowing integration with different authentication sources like property files, LDAP, Active Directory, databases, etc. The AMQ Broker Operator facilitates mounting JAAS configuration files into the broker pod.
*   **OpenShift OAuth:** Integration with OpenShift's built-in OAuth server for user authentication, leveraging existing OpenShift user identities.
*   **SSL Client Certificates:** Using client certificates for mutual TLS authentication.

For this lab, we will use a file-based JAAS authentication, which is simple to set up and effectively demonstrates the JAAS mechanism.

=== 1.2 Authorization

Authorization determines what an authenticated user or application is allowed to do once connected to the broker. AMQ Broker uses Access Control Lists (ACLs) to define granular permissions for:

*   **Connecting:** Who can establish a connection.
*   **Sending:** Who can send messages to specific addresses or queues.
*   **Receiving:** Who can consume messages from specific addresses or queues.
*   **Creating Durable Subscriptions/Addresses:** Who can create durable subscriptions or new addresses.
*   **Management:** Who can perform administrative operations via the broker's management interfaces.

ACLs are typically configured based on roles, where users are assigned roles, and roles are granted specific permissions.

=== 1.3 Secure Communication (SSL/TLS)

SSL/TLS (Secure Sockets Layer/Transport Layer Security) encrypts data transmitted between clients and the AMQ Broker, protecting it from eavesdropping and tampering. It also enables server authentication (clients verify the broker's identity) and, optionally, client authentication (the broker verifies the client's identity).

Implementing SSL/TLS involves:

*   **Keystore:** A repository for the broker's private key and its corresponding digital certificate. The private key is used to sign outgoing messages and decrypt incoming ones.
*   **Truststore:** A repository for trusted certificates (e.g., the Certificate Authority (CA) certificate that signed the broker's certificate, or client certificates for mutual TLS). Clients use the truststore to verify the broker's identity, and the broker uses it to verify client identities.

We will configure an SSL/TLS-enabled acceptor on the broker to secure client connections, ensuring all data transmitted over this acceptor is encrypted.

== 2. Prerequisites for the Lab

Before proceeding, ensure you have:

*   An OpenShift cluster where you have `cluster-admin` or `developer` privileges for your project.
*   The `oc` command-line tool installed and configured to connect to your cluster.
*   An AMQ Broker instance named `my-broker` running in your OpenShift project. If you don't have one, you can deploy a basic instance using the following command (replace `your-project` with your actual project name).

[source,bash]
----
# Replace 'your-project' with your OpenShift project name
oc new-project your-project # If you don't have a project yet

# Make sure the AMQ Broker Operator is installed in your cluster and available in your project.
# You typically install it from the OpenShift console OperatorHub.

# Deploy a basic AMQ Broker instance (if not already done).
# Note: The extraMounts section is added preemptively. We will create the ConfigMaps and Secrets later.
cat <<EOF | oc apply -f -
apiVersion: broker.amq.io/v1beta1
kind: ActiveMQArtemis
metadata:
  name: my-broker
spec:
  deploymentPlan:
    size: 1
    image: registry.redhat.io/amq7/amq-broker-rhel8:7.12
    extraMounts:
      configMaps:
        - name: login-config
        - name: acl-config
      secrets:
        - name: broker-tls-certs
EOF
----
[IMPORTANT]
====
If your `my-broker` instance already exists, you will need to `oc edit activemqartemis my-broker` later to add or modify the `extraMounts`, `brokerProperties`, `securityConfig`, and `acceptors` sections as instructed in the following steps. If you created a new broker using the above command, these mount points are already declared, and you will just be adding content via ConfigMaps/Secrets.
====

Ensure your broker is in a `Running` state:
[source,bash]
----
oc get activemqartemis my-broker
----

== 3. Implementing File-Based JAAS Authentication

We will configure a `login.config` file that uses a `PropertiesLoginModule` to authenticate users from `users.properties` and assign them to roles defined in `groups.properties`.

=== 3.1 Step 1: Define Users and Roles

Create the following files locally in your working directory.

.Save as `users.properties`
[source,properties]
----
# users.properties
# Format: username=password
admin=admin_password
developer=dev_password
reader=reader_password
----

.Save as `groups.properties`
[source,properties]
----
# groups.properties
# Format: role=user1,user2,...
admins=admin
developers=developer
readers=reader
----

=== 3.2 Step 2: Create JAAS `login.config`

Create the following file locally. This configuration tells the broker to use the `PropertiesLoginModule` and points it to our `users.properties` and `groups.properties` files.

.Save as `login.config`
[source,properties]
----
# login.config
artemis {
   org.apache.activemq.artemis.spi.core.security.jaas.PropertiesLoginModule required
   userGroupMappingMode=PROPERTIES
   org.apache.activemq.artemis.jaas.properties.user="users.properties"
   org.apache.activemq.artemis.jaas.properties.group="groups.properties";
};
----

=== 3.3 Step 3: Create an OpenShift ConfigMap for Authentication

Now, create an OpenShift `ConfigMap` named `login-config` containing these authentication files. The AMQ Broker Operator will use this ConfigMap to mount the files into the broker pod.

[source,bash]
----
oc create configmap login-config \
  --from-file=users.properties \
  --from-file=groups.properties \
  --from-file=login.config
----

Verify the ConfigMap is created and contains the correct keys:
[source,bash]
----
oc get configmap login-config -o yaml
----

=== 3.4 Step 4: Update the AMQ Broker CR to Use the ConfigMap

We need to modify the `ActiveMQArtemis` custom resource (`my-broker`) to mount this `ConfigMap` into the broker pod and instruct the broker to use this JAAS configuration.

Edit your `my-broker` instance:
[source,bash]
----
oc edit activemqartemis my-broker
----

Add or modify the `spec.deploymentPlan.extraMounts` section to include the `login-config` ConfigMap. Then, add `spec.brokerProperties` to point to the `login.config` file and enable security.

[source,yaml]
----
# ... (existing ActiveMQArtemis CR content) ...
spec:
  deploymentPlan:
    size: 1
    image: registry.redhat.io/amq7/amq-broker-rhel8:7.12
    extraMounts:
      configMaps:
        - name: login-config # <1>
        - name: acl-config   # Will be used later
      secrets:
        - name: broker-tls-certs # Will be used later
  brokerProperties:
    - "java.security.auth.login.config=/etc/activemq/conf/login-config/login.config" # <2>
    - "security.enabled=true" # <3>
# ... (rest of the CR) ...
----
<1> Ensures the `login-config` ConfigMap is mounted into `/etc/activemq/conf/login-config` inside the broker pod.
<2> Sets the Java system property to specify the JAAS configuration file.
<3> Explicitly enables security on the broker.

Save and exit the editor. The AMQ Broker Operator will detect the change and restart the broker pod.

=== 3.5 Step 5: Verify Authentication

Once the broker pod is `Running` again, let's verify that authentication is working. We'll use the `artemis` client tool from within the broker pod.

First, get the name of your broker pod:
[source,bash]
----
BROKER_POD=$(oc get pod -l app=my-broker -o jsonpath='{.items[0].metadata.name}')
echo "Broker Pod: $BROKER_POD"
----

.Test connection without credentials (should fail)
[source,bash]
----
oc exec -it $BROKER_POD -- sh -c "artemis consumer --url tcp://localhost:61616"
----
You should see an error indicating `Login failed` or `AuthenticationException`.

.Test connection with invalid credentials (should fail)
[source,bash]
----
oc exec -it $BROKER_POD -- sh -c "artemis consumer --url tcp://localhost:61616 --user baduser --password badpass"
----
This should also result in a `Login failed` error.

.Test connection with valid credentials (should succeed, consumer will wait for messages)
[source,bash]
----
oc exec -it $BROKER_POD -- sh -c "artemis consumer --url tcp://localhost:61616 --user developer --password dev_password"
----
If successful, the command will simply hang, waiting for messages. Press `Ctrl+C` to exit the consumer. This confirms that the `developer` user can authenticate.

== 4. Implementing Authorization with ACLs

Now that users can authenticate, we need to define what they are allowed to do. We'll create an `acl.xml` file with security settings and load it into the broker.

=== 4.1 Step 1: Define ACL Rules

Create the following file locally. This `acl.xml` will be integrated into the broker's main configuration.

.Save as `acl.xml`
[source,xml]
----
<!-- acl.xml -->
<configuration xmlns="urn:activemq"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="urn:activemq ../schema/artemis-server.xsd">

   <security-settings>
      <!-- Default policy for everyone, no access.
           This catch-all rule defines permissions for all addresses (#). -->
      <security-setting match="#">
         <permission type="createAddress" roles="admins"/>
         <permission type="deleteAddress" roles="admins"/>
         <permission type="createDurableQueue" roles="admins"/>
         <permission type="deleteDurableQueue" roles="admins"/>
         <permission type="createNonDurableQueue" roles="admins,developers"/>
         <permission type="deleteNonDurableQueue" roles="admins,developers"/>
         <permission type="send" roles="admins,developers"/>
         <permission type="consume" roles="admins,developers,readers"/>
         <permission type="browse" roles="admins,developers,readers"/>
         <permission type="manage" roles="admins"/>
      </security-setting>

      <!-- Specific permissions for a 'private.queue' address.
           This rule overrides the default for this specific address. -->
      <security-setting match="private.queue">
         <permission type="send" roles="admins,developers"/>
         <permission type="consume" roles="admins"/>
      </security-setting>

      <!-- Allow specific permissions for management address for admins. -->
      <security-setting match="activemq.management#">
         <permission type="send" roles="admins"/>
         <permission type="consume" roles="admins"/>
         <permission type="browse" roles="admins"/>
         <permission type="createAddress" roles="admins"/>
         <permission type="deleteAddress" roles="admins"/>
         <permission type="createDurableQueue" roles="admins"/>
         <permission type="deleteDurableQueue" roles="admins"/>
         <permission type="createNonDurableQueue" roles="admins"/>
         <permission type="deleteNonDurableQueue" roles="admins"/>
         <permission type="manage" roles="admins"/>
      </security-setting>
   </security-settings>
</configuration>
----
This `acl.xml` configuration defines:

*   A default security policy (`match="#"`) allowing `admins` to create/delete addresses/queues, `admins` and `developers` to create/delete non-durable queues and send messages, and `admins`, `developers`, and `readers` to consume/browse messages. The `admins` role has full management privileges.
*   A specific rule for the `private.queue` address where only `admins` can consume messages, while both `admins` and `developers` can send.
*   Permissions for the broker's management address (`activemq.management#`) are restricted to the `admins` role.

=== 4.2 Step 2: Create an OpenShift ConfigMap for ACLs

Create an OpenShift `ConfigMap` named `acl-config` from the `acl.xml` file.

[source,bash]
----
oc create configmap acl-config \
  --from-file=acl.xml
----

Verify the ConfigMap is created:
[source,bash]
----
oc get configmap acl-config -o yaml
----

=== 4.3 Step 3: Update the AMQ Broker CR to Use the ACL ConfigMap

Edit your `my-broker` instance again:
[source,bash]
----
oc edit activemqartemis my-broker
----

Ensure `spec.deploymentPlan.extraMounts.configMaps` includes `acl-config`. Then, add a `securityConfig` section to the broker CR to load this `acl.xml` file.

[source,yaml]
----
# ... (existing ActiveMQArtemis CR content) ...
spec:
  deploymentPlan:
    size: 1
    image: registry.redhat.io/amq7/amq-broker-rhel8:7.12
    extraMounts:
      configMaps:
        - name: login-config
        - name: acl-config # <1>
      secrets:
        - name: broker-tls-certs
  brokerProperties:
    - "java.security.auth.login.config=/etc/activemq/conf/login-config/login.config"
    - "security.enabled=true"
  securityConfig: # <2>
    brokerXml:
      configMaps:
        - name: acl-config
          key: acl.xml
          mountPath: /home/jboss/broker/etc/broker-security.xml # <3>
# ... (rest of the CR) ...
----
<1> Ensures the `acl-config` ConfigMap is mounted.
<2> This section instructs the Operator to inject the content of `acl.xml` into the broker's configuration.
<3> Specifies the standard location where the broker expects to find additional security configuration XML.

Save and exit. The broker pod will restart.

=== 4.4 Step 4: Verify Authorization

Once the broker is running, let's test the ACLs by attempting to send and consume messages as different users.

Get the broker pod name:
[source,bash]
----
BROKER_POD=$(oc get pod -l app=my-broker -o jsonpath='{.items[0].metadata.name}')
echo "Broker Pod: $BROKER_POD"
----

.Test `developer` sending to `test.queue` (should succeed based on `match="#"` rule)
[source,bash]
----
oc exec -it $BROKER_POD -- sh -c "artemis producer --url tcp://localhost:61616 --user developer --password dev_password --destination queue://test.queue --message-count 1"
----
You should see `Produced 1 messages.`

.Test `reader` sending to `test.queue` (should fail - unauthorized, as `reader` is not in `developers` or `admins` role for `send` permission)
[source,bash]
----
oc exec -it $BROKER_POD -- sh -c "artemis producer --url tcp://localhost:61616 --user reader --password reader_password --destination queue://test.queue --message-count 1"
----
You should see an error like `ActiveMQSecurityException` or `User 'reader' does not have permission to send messages to address 'test.queue'`.

.Test `developer` consuming from `test.queue` (should succeed based on `match="#"` rule)
[source,bash]
----
oc exec -it $BROKER_POD -- sh -c "artemis consumer --url tcp://localhost:61616 --user developer --password dev_password --destination queue://test.queue --message-count 1"
----
You should see `Consumed 1 messages.`

.Test `admin` consuming from `private.queue` (should succeed based on `match="private.queue"` rule)
[source,bash]
----
oc exec -it $BROKER_POD -- sh -c "artemis consumer --url tcp://localhost:61616 --user admin --password admin_password --destination queue://private.queue"
----
This consumer will wait for messages. Press `Ctrl+C` to exit.

.Test `developer` consuming from `private.queue` (should fail - unauthorized, as `developer` is not in `admins` role for `consume` permission on `private.queue`)
[source,bash]
----
oc exec -it $BROKER_POD -- sh -c "artemis consumer --url tcp://localhost:61616 --user developer --password dev_password --destination queue://private.queue"
----
You should see an error like `ActiveMQSecurityException` or `User 'developer' does not have permission to consume from address 'private.queue'`.

These tests confirm your ACLs are working as expected, enforcing fine-grained authorization.

== 5. Securing Communication with SSL/TLS

Finally, we will set up SSL/TLS for secure client-broker communication. This involves generating a certificate, creating OpenShift Secrets for the keystore and truststore, and configuring an SSL-enabled acceptor on the broker.

=== 5.1 Step 1: Generate Self-Signed Certificates

For a lab environment, we will generate a self-signed certificate. In a production environment, you would obtain certificates from a trusted Certificate Authority (CA) or use OpenShift's Service Serving Certificate capabilities.

[source,bash]
----
# Ensure you are in your working directory

# 1. Generate a private key for the broker
openssl genrsa -out broker.key 2048

# 2. Generate a Certificate Signing Request (CSR) for the broker
# The Common Name (CN) should match the broker's service FQDN for client verification.
# Replace 'your-project' with your actual OpenShift project name.
openssl req -new -key broker.key -out broker.csr \
    -subj "/CN=my-broker-amqp.your-project.svc.cluster.local"

# 3. Self-sign the certificate using its own key (valid for 365 days)
openssl x509 -req -days 365 -in broker.csr -signkey broker.key -out broker.crt

# 4. Create a PKCS12 keystore (broker.p12) from the key and certificate
# This will prompt you for an export password for the PKCS12 file. Use 'password' for simplicity.
openssl pkcs12 -export -out broker.p12 -inkey broker.key -in broker.crt -name mybroker -password pass:password

# 5. Create a Java Keystore (broker.jks) from the PKCS12 file
# This will prompt for the source (PKCS12) password and a new destination (JKS) password. Use 'password' for both.
keytool -importkeystore -srckeystore broker.p12 -srcstoretype PKCS12 -destkeystore broker.jks -deststoretype JKS -storepass password -srcstorepass password

# 6. Create a Java Truststore (client.jks) for the client, containing the broker's public certificate
# This will allow the client to trust the broker's self-signed certificate.
# This will prompt for a password for the truststore. Use 'password' for simplicity.
keytool -import -trustcacerts -file broker.crt -alias mybroker -keystore client.jks -storepass password -noprompt
----

You should now have `broker.jks` (broker's keystore) and `client.jks` (client's truststore) files in your directory.

=== 5.2 Step 2: Create OpenShift Secrets for TLS

We'll create two secrets: one for the broker's keystore (`broker-tls-certs`) and another for the client's truststore (`client-tls-truststore`). The broker will use its keystore, and a client pod will use the truststore to verify the broker.

[source,bash]
----
# Create secret for broker keystore (containing broker.jks and its password)
oc create secret generic broker-tls-certs \
  --from-file=broker.jks \
  --from-literal=password=password # Keystore password

# Create secret for client truststore (containing client.jks and its password)
oc create secret generic client-tls-truststore \
  --from-file=client.jks \
  --from-literal=password=password # Truststore password
----

Verify the `broker-tls-certs` and `client-tls-truststore` Secrets are created:
[source,bash]
----
oc get secret broker-tls-certs -o yaml
oc get secret client-tls-truststore -o yaml
----

=== 5.3 Step 3: Update the AMQ Broker CR for SSL/TLS

Edit your `my-broker` instance again:
[source,bash]
----
oc edit activemqartemis my-broker
----

Ensure `spec.deploymentPlan.extraMounts.secrets` includes `broker-tls-certs`. Then, add a new acceptor configuration to enable SSL/TLS on a dedicated port.

[source,yaml]
----
# ... (existing ActiveMQArtemis CR content) ...
spec:
  deploymentPlan:
    size: 1
    image: registry.redhat.io/amq7/amq-broker-rhel8:7.12
    extraMounts:
      configMaps:
        - name: login-config
        - name: acl-config
      secrets:
        - name: broker-tls-certs # <1>
  brokerProperties:
    - "java.security.auth.login.config=/etc/activemq/conf/login-config/login.config"
    - "security.enabled=true"
  securityConfig:
    brokerXml:
      configMaps:
        - name: acl-config
          key: acl.xml
          mountPath: /home/jboss/broker/etc/broker-security.xml
  acceptors: # <2> Add or modify this section for SSL/TLS
    - name: ssl-amqp
      protocols: AMQP
      port: 5671 # <3> Standard AMQPS port
      sslEnabled: true
      sslCert:
        secretName: broker-tls-certs
        items:
          - key: broker.jks
            path: broker.jks # Path within the mounted secret directory
      sslKeyStorePassword:
        secretName: broker-tls-certs
        items:
          - key: password
            path: password # Path within the mounted secret directory
# ... (rest of the CR) ...
----
<1> Ensures the `broker-tls-certs` Secret is mounted, making `broker.jks` and its password available to the broker.
<2> This section configures a new network acceptor for AMQP protocol with SSL/TLS enabled.
<3> `5671` is the standard port for AMQP over TLS (AMQPS).

[NOTE]
====
The `acceptors` configuration automatically handles mounting the `broker-tls-certs` Secret into a standard location within the broker pod and configures the SSL context for the new `ssl-amqp` acceptor.
====

Save and exit. The broker pod will restart.

=== 5.4 Step 4: Verify SSL/TLS Communication

Once the broker is running again, we can test secure communication.

First, expose the new SSL acceptor. We'll create a new `Service` and `Route` for external access to the secure AMQP port.

[source,bash]
----
# Create a new Service specifically for the SSL-enabled acceptor
cat <<EOF | oc apply -f -
apiVersion: v1
kind: Service
metadata:
  labels:
    app: my-broker
  name: my-broker-amqps
spec:
  ports:
  - name: amqps-tcp
    port: 5671
    protocol: TCP
    targetPort: 5671
  selector:
    app: my-broker
  sessionAffinity: None
  type: ClusterIP # Use ClusterIP for internal access
EOF

# Expose the AMQPS service via a Route for external access (for demo purposes)
# Note: OpenShift Routes are primarily for HTTP/HTTPS. For raw TCP/TLS, a Passthrough Route is needed.
# This assumes your OpenShift Ingress Controller is configured for passthrough.
oc create route passthrough my-broker-amqps-route --service=my-broker-amqps --port=amqps-tcp --insecure-policy=None
----
[IMPORTANT]
====
For external client access to a raw TCP/TLS port (like 5671), you typically need a `Route` with `termination: passthrough` or a `Service` of type `LoadBalancer` or `NodePort`. The `passthrough` route needs Ingress Controller support. If your Route doesn't work, you might need to connect from within the OpenShift cluster or consider alternative exposure methods.
====

To test from within OpenShift, we will deploy a temporary client pod.

.Create a client application pod
[source,yaml]
----
cat <<EOF | oc apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: test-client
spec:
  containers:
  - name: client-container
    image: registry.redhat.io/amq7/amq-broker-rhel8:7.12 # Use broker image for client tools
    command: ["tail", "-f", "/dev/null"] # Keep the container running
    env:
      - name: AMQ_BROKER_CLIENT_TRUSTSTORE # Environment variable for client-side truststore path
        value: "/var/run/secrets/client-tls-truststore/client.jks"
      - name: AMQ_BROKER_CLIENT_TRUSTSTORE_PASSWORD # Environment variable for client-side truststore password
        value: "password"
    volumeMounts:
    - name: client-truststore-volume
      mountPath: "/var/run/secrets/client-tls-truststore"
      readOnly: true
  volumes:
  - name: client-truststore-volume
    secret:
      secretName: client-tls-truststore # Mount the client truststore secret
EOF
----

Wait for the `test-client` pod to be running:
[source,bash]
----
oc get pod test-client
----

Now, connect securely from the `test-client` pod using `oc exec`.

[source,bash]
----
# Get the broker's internal service hostname
BROKER_SERVICE_HOSTNAME="my-broker-amqp.your-project.svc.cluster.local" # Adjust 'your-project' if needed

# Connect from the client pod using SSL/TLS, valid credentials, and truststore
oc exec -it test-client -- sh -c "artemis consumer \
  --url \"amqps://${BROKER_SERVICE_HOSTNAME}:5671\" \
  --user developer --password dev_password \
  --destination queue://test.queue \
  --connection-option \"SSL_ENABLED=true\" \
  --connection-option \"TRUST_STORE_PATH=${AMQ_BROKER_CLIENT_TRUSTSTORE}\" \
  --connection-option \"TRUST_STORE_PASSWORD=${AMQ_BROKER_CLIENT_TRUSTSTORE_PASSWORD}\""
----

This command should successfully connect to the AMQ Broker via SSL/TLS and wait for messages. If you receive an error related to SSL handshake or untrusted certificates, double-check your certificate generation, `client.jks`, and `sslCert` configuration in the `ActiveMQArtemis` CR. Press `Ctrl+C` to exit.

.Test connecting to the SSL port without SSL enabled (should fail)
[source,bash]
----
oc exec -it test-client -- sh -c "artemis consumer \
  --url \"tcp://${BROKER_SERVICE_HOSTNAME}:5671\" \
  --user developer --password dev_password \
  --destination queue://test.queue"
----
This should fail with a protocol error or connection reset, confirming that the `ssl-amqp` acceptor is correctly enforcing SSL/TLS.

You have now successfully configured file-based JAAS authentication, ACL-based authorization, and SSL/TLS secure communication for your AMQ Broker on OpenShift!

== 6. Cleanup (Optional)

To remove the resources created in this lab and revert your broker configuration:

[source,bash]
----
# Delete ConfigMaps and Secrets
oc delete configmap login-config acl-config
oc delete secret broker-tls-certs client-tls-truststore

# Delete the test client pod and AMQPS service/route
oc delete pod test-client
oc delete service my-broker-amqps
oc delete route my-broker-amqps-route

# Edit your broker CR to remove the security configurations
oc edit activemqartemis my-broker
# Manually remove the 'brokerProperties' entries for java.security.auth.login.config and security.enabled
# Manually remove the entire 'securityConfig' section
# Manually remove the 'ssl-amqp' entry from the 'acceptors' list
# Manually remove the `extraMounts` entries for login-config, acl-config, and broker-tls-certs if they were added solely for this lab.

# If you created the broker just for this lab, you can delete it:
# oc delete activemqartemis my-broker

# Delete local files generated during certificate creation
rm -f users.properties groups.properties login.config acl.xml broker.key broker.csr broker.crt broker.p12 broker.jks client.jks
----